#!/bin/bash
set -e

# Enhanced Kamal Setup Script for Asset Management System
# This script handles the complete deployment workflow from configuration to deployment

echo "🚀 Kamal Deployment Setup for Asset Management System"
echo "=================================================="

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Function to collect user input with default values
collect_input() {
    local prompt="$1"
    local default="$2"
    local var_name="$3"
    
    if [ -n "$default" ]; then
        read -p "$prompt [$default]: " input
        eval "$var_name=\"\${input:-$default}\""
    else
        read -p "$prompt: " input
        eval "$var_name=\"$input\""
    fi
}

# Function to show configuration summary
show_summary() {
    echo ""
    echo -e "${BLUE}📋 Configuration Summary${NC}"
    echo "========================"
    echo "Deployment Server: $SERVER_HOST"
    echo "SSH User: $SSH_USER"
    echo "SSH Port: $SSH_PORT"
    echo "Registry: $REGISTRY_URL (pre-built images)"
    echo "Registry User: $REGISTRY_USERNAME"
    echo "Database: $DATABASE_NAME"
    echo "Storage: Local (persistent host volume)"
    echo "Application Domain: $FRONTEND_DOMAIN"
    echo "API Path: /api (same domain)"
    echo "SSL Email: $SSL_EMAIL"
    echo "Environment: $RAILS_ENV"
    echo "Web Concurrency: $WEB_CONCURRENCY"
    echo "Max Threads: $RAILS_MAX_THREADS"
    echo "Build Platform: $BUILD_ARCH"
    echo "Logging: $DETAILED_LOGGING ($LOG_LEVEL)"
    echo ""
}

# Function to load configuration from .env.setup_kamal file
load_env_config() {
    local env_file=".env.setup_kamal"
    
    if [ ! -f "$env_file" ]; then
        echo -e "${RED}❌ Error: .env.setup_kamal file not found${NC}"
        echo "Please create the configuration file first:"
        echo "  1. Copy env.setup_kamal.example to .env.setup_kamal"
        echo "  2. Edit .env.setup_kamal with your configuration values"
        echo "  3. Run this script again with --dev -p"
        echo ""
        echo "Example:"
        echo "  cp env.setup_kamal.example .env.setup_kamal"
        echo "  # Edit .env.setup_kamal with your values"
        echo "  ./bin/setup_kamal --dev -p"
        exit 1
    fi
    
    echo -e "${BLUE}📄 Loading configuration from .env.setup_kamal...${NC}"
    
    # Source the environment file
    source "$env_file"
    
    # Validate required variables
    local required_vars=(
        "FRONTEND_DOMAIN"
        "SERVER_HOST" 
        "SSH_USER"
        "SSH_PORT"
        "KAMAL_REGISTRY_TOKEN"
        "POSTGRES_PASSWORD"
        "DATABASE_NAME"
        "SSL_EMAIL"
        "RAILS_ENV"
        "WEB_CONCURRENCY"
        "RAILS_MAX_THREADS"
        "BUILD_ARCH"
        "DETAILED_LOGGING"
        "LOG_LEVEL"
    )
    
    local missing_vars=()
    for var in "${required_vars[@]}"; do
        if [ -z "${!var}" ]; then
            missing_vars+=("$var")
        fi
    done
    
    if [ ${#missing_vars[@]} -gt 0 ]; then
        echo -e "${RED}❌ Error: Missing required variables in .env.setup_kamal:${NC}"
        for var in "${missing_vars[@]}"; do
            echo "  - $var"
        done
        echo ""
        echo "Please check your .env.setup_kamal file and ensure all required variables are set."
        exit 1
    fi
    
    # Set derived variables
    API_DOMAIN="$FRONTEND_DOMAIN"
    REGISTRY_SERVER="${REGISTRY_SERVER:-registry.digitalocean.com}"
    REGISTRY_NAMESPACE="${REGISTRY_NAMESPACE:-cervera}"
    REGISTRY_USERNAME="${REGISTRY_USERNAME:-do_access_token}"
    STORAGE_TYPE="${STORAGE_TYPE:-local}"
    
    echo -e "${GREEN}✅ Configuration loaded successfully from .env.setup_kamal${NC}"
}

# Function to collect all configuration
collect_config() {
    local dev_mode="$1"
    local preset_mode="$2"
    
    # If in preset mode, skip all interactive questions
    if [ "$preset_mode" = "-p" ]; then
        echo -e "${GREEN}✅ Using preset configuration from .env.setup_kamal${NC}"
        return 0
    fi
    
    # DNS Requirements Explanation
    echo ""
    echo -e "${BLUE}🌐 DNS Setup Requirements${NC}"
    echo "============================="
    echo "The Asset Management System requires TWO separate domain names:"
    echo ""
    echo "1. Application Domain: Where users access the web interface and API"
    echo "   Example: assets.yourdomain.com"
    echo "   - Web interface: https://assets.yourdomain.com"
    echo "   - API endpoints: https://assets.yourdomain.com/api"
    echo ""
    echo "2. Server Domain: The server where Docker runs and hosts the application"
    echo "   Example: cloud.yourdomain.com (or use IP address)"
    echo ""
    echo -e "${YELLOW}📋 You need to create TWO DNS A records pointing to your server:${NC}"
    echo "   - Application domain → Your server IP"
    echo "   - Server domain → Your server IP"
    echo ""
    echo "Example DNS records:"
    echo "   assets.yourdomain.com     A    YOUR_SERVER_IP"
    echo "   cloud.yourdomain.com      A    YOUR_SERVER_IP"
    echo ""
    read -p "Press Enter to continue with domain configuration..."
    echo ""

    # Domain Configuration
    echo -e "${BLUE}🌐 Domain Configuration${NC}"
    echo "=========================="
    
    # Function to validate domain name
    validate_domain() {
        local domain="$1"
        echo -e "${BLUE}🔍 Validating domain name: $domain${NC}"
        
        if command -v nslookup &> /dev/null; then
            if nslookup "$domain" &> /dev/null; then
                echo -e "${GREEN}✅ Domain resolves successfully${NC}"
                return 0
            else
                echo -e "${RED}❌ Domain does not resolve${NC}"
                return 1
            fi
        elif command -v dig &> /dev/null; then
            if dig +short "$domain" | grep -q .; then
                echo -e "${GREEN}✅ Domain resolves successfully${NC}"
                return 0
            else
                echo -e "${RED}❌ Domain does not resolve${NC}"
                return 1
            fi
        else
            echo -e "${YELLOW}⚠️  Cannot validate domain (nslookup/dig not available)${NC}"
            return 0
        fi
    }
    
    # Collect frontend domain name with validation
    while true; do
        collect_input "Frontend domain name (e.g., assets.yourdomain.com)" "" "FRONTEND_DOMAIN"
        
        if validate_domain "$FRONTEND_DOMAIN"; then
            break
        else
            echo ""
            echo -e "${YELLOW}⚠️  The domain '$FRONTEND_DOMAIN' does not resolve to an IP address.${NC}"
            echo "This could mean:"
            echo "  - The domain name is misspelled"
            echo "  - DNS records haven't been set up yet"
            echo "  - The domain is not pointing to your server"
            echo ""
            read -p "Do you want to edit the domain name? (y/n): " edit_domain
            case $edit_domain in
                [Yy]* )
                    echo "Please enter the correct domain name:"
                    continue
                    ;;
                [Nn]* )
                    echo -e "${YELLOW}⚠️  Proceeding with unresolved domain. Make sure DNS is configured before deployment.${NC}"
                    break
                    ;;
                * )
                    echo -e "${YELLOW}Please answer y (yes) or n (no).${NC}"
                    ;;
            esac
        fi
    done
    
    # API will use the same domain as frontend with /api path prefix
    API_DOMAIN="$FRONTEND_DOMAIN"
    echo -e "${GREEN}✅ API will be accessible at: http://$API_DOMAIN/api${NC}"

    # Deployment Server Configuration
    echo ""
    echo -e "${BLUE}🖥️  Deployment Server Configuration${NC}"
    echo "====================================="
    echo "This is the server where the Asset Management System will be deployed."
    echo "It should be a Linux server (Ubuntu/CentOS/Debian)."
    echo "Docker will be installed automatically by Kamal if not present."
    echo "The server will host both the frontend and API applications."
    echo ""
    collect_input "Deployment Server hostname or IP address" "" "SERVER_HOST"
    collect_input "SSH username" "root" "SSH_USER"
    collect_input "SSH port" "22" "SSH_PORT"

    echo ""
    echo -e "${BLUE}🐳 Docker Registry Configuration${NC}"
    echo "=================================="
    echo "Using pre-built images from DigitalOcean Container Registry"
    REGISTRY_SERVER="registry.digitalocean.com"
    REGISTRY_NAMESPACE="cervera"
    REGISTRY_USERNAME="do_access_token"
    echo "Registry Server: $REGISTRY_SERVER"
    echo "Registry Namespace: $REGISTRY_NAMESPACE"
    echo "Registry Username: $REGISTRY_USERNAME"
    echo ""
    
    # Check if running in developer mode
    if [ "$dev_mode" = "--dev" ]; then
        echo -e "${BLUE}🔧 Developer Mode: Building and pushing images${NC}"
        
        # First, try to load the token from shell profile if not already set
        if [ -z "$KAMAL_REGISTRY_TOKEN" ]; then
            if [ -n "$ZSH_VERSION" ]; then
                source ~/.zshrc 2>/dev/null || true
            elif [ -n "$BASH_VERSION" ]; then
                source ~/.bashrc 2>/dev/null || true
            fi
        fi
        
        # Check for existing environment variable
        if [ -n "$KAMAL_REGISTRY_TOKEN" ]; then
            echo -e "${GREEN}✅ Using existing KAMAL_REGISTRY_TOKEN from environment variable${NC}"
            echo "Token: ${KAMAL_REGISTRY_TOKEN:0:20}...${KAMAL_REGISTRY_TOKEN: -10}"
            echo ""
            read -p "Want to use a different token? (y/n): " change_token
            case $change_token in
                [Yy]* )
                    collect_input "Enter new DigitalOcean Registry Access Token" "" "KAMAL_REGISTRY_TOKEN"
                    read -p "Save this token to KAMAL_REGISTRY_TOKEN environment variable? (y/n): " save_token
                    case $save_token in
                        [Yy]* )
                            echo "export KAMAL_REGISTRY_TOKEN=\"$KAMAL_REGISTRY_TOKEN\"" >> ~/.bashrc
                            echo "export KAMAL_REGISTRY_TOKEN=\"$KAMAL_REGISTRY_TOKEN\"" >> ~/.zshrc
                            echo -e "${GREEN}✅ Token saved to environment variables${NC}"
                            
                            # Export in current session
                            export KAMAL_REGISTRY_TOKEN="$KAMAL_REGISTRY_TOKEN"
                            echo -e "${GREEN}✅ Token loaded in current session${NC}"
                            
                            # Also source the shell profile to ensure it's available
                            if [ -n "$ZSH_VERSION" ]; then
                                source ~/.zshrc 2>/dev/null || true
                            elif [ -n "$BASH_VERSION" ]; then
                                source ~/.bashrc 2>/dev/null || true
                            fi
                            ;;
                    esac
                    ;;
                [Nn]* )
                    echo "Continuing with existing token..."
                    ;;
            esac
        else
            collect_input "Enter DigitalOcean Registry Access Token (read/write for building)" "" "KAMAL_REGISTRY_TOKEN"
            read -p "Save this token to KAMAL_REGISTRY_TOKEN environment variable? (y/n): " save_token
            case $save_token in
                [Yy]* )
                    echo "export KAMAL_REGISTRY_TOKEN=\"$KAMAL_REGISTRY_TOKEN\"" >> ~/.bashrc
                    echo "export KAMAL_REGISTRY_TOKEN=\"$KAMAL_REGISTRY_TOKEN\"" >> ~/.zshrc
                    echo -e "${GREEN}✅ Token saved to environment variables${NC}"
                    
                    # Export in current session
                    export KAMAL_REGISTRY_TOKEN="$KAMAL_REGISTRY_TOKEN"
                    echo -e "${GREEN}✅ Token loaded in current session${NC}"
                    
                    # Also source the shell profile to ensure it's available
                    if [ -n "$ZSH_VERSION" ]; then
                        source ~/.zshrc 2>/dev/null || true
                    elif [ -n "$BASH_VERSION" ]; then
                        source ~/.bashrc 2>/dev/null || true
                    fi
                    ;;
            esac
        fi
    else
        echo "You need a read-only access token to pull the pre-built images."
        echo "Contact the developer to obtain your DigitalOcean registry access token."
        collect_input "DigitalOcean Registry Access Token (contact developer for access)" "" "KAMAL_REGISTRY_TOKEN"
    fi

    echo ""
    echo -e "${BLUE}🗄️ Database Configuration${NC}"
    echo "============================="
    collect_input "Create database password" "" "POSTGRES_PASSWORD"
    collect_input "Database name" "asset_management_production" "DATABASE_NAME"

    echo ""
    echo -e "${BLUE}📦 Storage Configuration${NC}"
    echo "============================="
    echo "Using local storage - files will be stored directly on the server"
    echo "with persistent host storage volume."
    echo ""
    echo "Note: S3-compatible storage can be configured after deployment"
    echo "through the application's admin interface."
    
    STORAGE_TYPE="local"

    echo ""
    echo -e "${BLUE}🔐 SSL Configuration${NC}"
    echo "======================"
    echo "The system uses Let's Encrypt SSL certificates for secure HTTPS connections."
    echo "Let's Encrypt requires an email address to send notifications about certificate"
    echo "renewals and important security updates."
    collect_input "Email for Let's Encrypt SSL notifications" "" "SSL_EMAIL"

    echo ""
    echo -e "${BLUE}⚙️ Application Configuration${NC}"
    echo "==============================="
    collect_input "Application environment" "production" "RAILS_ENV"
    collect_input "Web concurrency (number of workers)" "2" "WEB_CONCURRENCY"
    collect_input "Max threads per worker" "5" "RAILS_MAX_THREADS"
    
    echo ""
    echo -e "${BLUE}🏗️ Build Platform Configuration${NC}"
    echo "=================================="
    echo "Choose the target deployment platform:"
    echo "1) AMD64 (x86_64) - Standard servers, most cloud providers"
    echo "2) ARM64 (aarch64) - Apple Silicon, ARM-based servers"
    read -p "Enter choice [1-2]: " platform_choice
    
    case $platform_choice in
        1)
            BUILD_ARCH="amd64"
            echo "Using AMD64 platform - compatible with most servers"
            ;;
        2)
            BUILD_ARCH="arm64"
            echo "Using ARM64 platform - for Apple Silicon and ARM servers"
            echo -e "${YELLOW}Note: ARM64 support is experimental. Use AMD64 for production deployments.${NC}"
            ;;
        *)
            echo -e "${RED}Invalid choice. Defaulting to AMD64.${NC}"
            BUILD_ARCH="amd64"
            ;;
    esac

    echo ""
    echo -e "${BLUE}📊 Monitoring & Logging${NC}"
    echo "============================="
    collect_input "Enable detailed logging (true/false)" "true" "DETAILED_LOGGING"
    collect_input "Log level (debug/info/warn/error)" "info" "LOG_LEVEL"
}

# Function to get Rails master key
get_rails_master_key() {
    echo -e "${BLUE}🔑 Getting Rails master key...${NC}"
    if [ -f "apps/api/config/master.key" ]; then
        RAILS_MASTER_KEY=$(cat apps/api/config/master.key | tr -d '\n')
        echo -e "${GREEN}✅ Using existing Rails master key${NC}"
    else
        RAILS_MASTER_KEY=$(openssl rand -hex 16)
        echo -e "${GREEN}✅ Generated new Rails master key${NC}"
    fi
}

# Function to generate JWT secret
generate_jwt_secret() {
    echo -e "${BLUE}🔑 Generating JWT secret key...${NC}"
    JWT_SECRET_KEY=$(openssl rand -hex 32)
    echo -e "${GREEN}✅ JWT secret key generated${NC}"
}

# Function to create configuration files
create_config_files() {
    echo ""
    echo -e "${BLUE}🔧 Creating configuration files...${NC}"


    # Create apps/api/config/deploy.yml
    mkdir -p apps/api/config
    
    # Backup existing deploy.yml if it exists
    if [ -f "apps/api/config/deploy.yml" ]; then
        echo -e "${YELLOW}📦 Backing up existing deploy.yml to deploy.yml.bak${NC}"
        mv apps/api/config/deploy.yml apps/api/config/deploy.yml.bak
    fi
    
    cat > apps/api/config/deploy.yml << EOF
# Kamal 2.7.0 Configuration for Asset Management System
# Generated on $(date)

service: api
image: $REGISTRY_NAMESPACE/asset-management-system

# Deploy to these servers.
servers:
  web:
    hosts:
      - $SERVER_HOST
    cmd: bash -lc "until pg_isready -h api-postgres -p 5432 -U postgres; do echo 'Waiting for database...'; sleep 2; done && bin/rails db:prepare && bin/rails server -b 0.0.0.0 -p 3000"

# API is accessible through the proxy at /api path on the same domain
# Frontend accesses API via relative /api URLs
proxy:
  host: $FRONTEND_DOMAIN
  path_prefix: /api
  ssl: false
  app_port: 3000

# Credentials for your image host.
registry:
  server: $REGISTRY_SERVER
  username: $REGISTRY_USERNAME
  password:
    - KAMAL_REGISTRY_TOKEN

# Builder configuration for target platform
builder:
  arch: $BUILD_ARCH

# Inject ENV variables into containers (secrets come from .kamal/secrets).
env:
  secret:
    - RAILS_MASTER_KEY
    - JWT_SECRET_KEY
    - POSTGRES_PASSWORD
EOF

# Local storage - no additional secrets needed

cat >> apps/api/config/deploy.yml << EOF
  clear:
    RAILS_ENV: $RAILS_ENV
    RACK_ENV: $RAILS_ENV
    RAILS_LOG_TO_STDOUT: "1"
    RAILS_SERVE_STATIC_FILES: "true"
    ACTIVE_STORAGE_SERVICE: $STORAGE_TYPE
    DATABASE_URL: postgresql://postgres:$POSTGRES_PASSWORD@api-postgres:5432/$DATABASE_NAME
    REDIS_URL: redis://api-redis:6379/0

# Internal-only data stores
accessories:
  postgres:
    image: postgres:16
    host: $SERVER_HOST
    env:
      clear:
        POSTGRES_DB: $DATABASE_NAME
        POSTGRES_USER: postgres
      secret:
        - POSTGRES_PASSWORD
    directories:
      - postgres_data:/var/lib/postgresql/data

  redis:
    image: redis:7
    host: $SERVER_HOST
    cmd: redis-server --appendonly yes
    directories:
      - redis_data:/data
EOF

    # Local storage - no additional accessories needed

    # Close the accessories section
    cat >> apps/api/config/deploy.yml << EOF

# Named directories are unique per accessory to avoid accidental sharing
EOF


    # Create apps/api/.kamal/secrets
    mkdir -p apps/api/.kamal
    
    # Backup existing secrets if it exists
    if [ -f "apps/api/.kamal/secrets" ]; then
        echo -e "${YELLOW}🔒 Backing up existing secrets to secrets.bak${NC}"
        mv apps/api/.kamal/secrets apps/api/.kamal/secrets.bak
    fi
    
    cat > apps/api/.kamal/secrets << EOF
# Kamal secrets file
# Generated on $(date)

RAILS_MASTER_KEY=$RAILS_MASTER_KEY
JWT_SECRET_KEY=$JWT_SECRET_KEY
POSTGRES_PASSWORD=$POSTGRES_PASSWORD
KAMAL_REGISTRY_TOKEN=$KAMAL_REGISTRY_TOKEN
EOF

    # Add storage-specific secrets
    case $STORAGE_TYPE in
        local)
            # Local storage - no additional secrets needed
            ;;
        minio)
            cat >> apps/api/.kamal/secrets << EOF
MINIO_ROOT_PASSWORD=$MINIO_SECRET_KEY
EOF
            ;;
        aws)
            cat >> apps/api/.kamal/secrets << EOF
AWS_ACCESS_KEY_ID=$AWS_ACCESS_KEY_ID
AWS_SECRET_ACCESS_KEY=$AWS_SECRET_ACCESS_KEY
EOF
            ;;
        digitalocean)
            cat >> apps/api/.kamal/secrets << EOF
DO_SPACES_ACCESS_KEY=$DO_SPACES_ACCESS_KEY
DO_SPACES_SECRET_KEY=$DO_SPACES_SECRET_KEY
EOF
            ;;
    esac

    # Add database and Redis URLs
    cat >> apps/api/.kamal/secrets << EOF

# Database and Redis URLs
DATABASE_URL=postgresql://postgres:\$POSTGRES_PASSWORD@api-postgres:5432/$DATABASE_NAME
REDIS_URL=redis://api-redis:6379/0
EOF

    # Local storage configuration
    cat >> apps/api/.kamal/secrets << EOF

# Local storage configuration
ACTIVE_STORAGE_SERVICE=local
EOF

    # Create apps/web/config/deploy.yml
    mkdir -p apps/web/config
    
    # Backup existing deploy.yml if it exists
    if [ -f "apps/web/config/deploy.yml" ]; then
        echo -e "${YELLOW}📦 Backing up existing web deploy.yml to deploy.yml.bak${NC}"
        mv apps/web/config/deploy.yml apps/web/config/deploy.yml.bak
    fi
    
    cat > apps/web/config/deploy.yml << EOF
# Kamal 2.7.0 Configuration for Asset Management System Web Frontend
# Generated on $(date)

service: frontend
image: $REGISTRY_NAMESPACE/asset-management-system-web

# Deploy to these servers.
servers:
  web:
    hosts:
      - $SERVER_HOST
    cmd: node server.js

# SSL is handled by the proxy server
proxy:
  host: $FRONTEND_DOMAIN
  ssl: false
  healthcheck:
    path: /
    interval: 10
    timeout: 10

# Credentials for your image host.
registry:
  server: $REGISTRY_SERVER
  username: $REGISTRY_USERNAME
  password:
    - KAMAL_REGISTRY_PASSWORD

# Build configuration
builder:
  arch: $BUILD_ARCH
  context: .
  dockerfile: Dockerfile
  args:
    NEXT_PUBLIC_API_URL: /api

# Environment variables
env:
  clear:
    NODE_ENV: production
    PORT: 80
    HOSTNAME: 0.0.0.0
    # API URL points to the Rails API service via relative /api path
    NEXT_PUBLIC_API_URL: /api

# Logging
logging:
  driver: json-file
  options:
    max-size: "10m"
    max-file: "3"
EOF

    # Create apps/web/.kamal/secrets
    mkdir -p apps/web/.kamal
    
    # Backup existing secrets if it exists
    if [ -f "apps/web/.kamal/secrets" ]; then
        echo -e "${YELLOW}🔒 Backing up existing web secrets to secrets.bak${NC}"
        mv apps/web/.kamal/secrets apps/web/.kamal/secrets.bak
    fi
    
    cat > apps/web/.kamal/secrets << EOF
# Kamal secrets file for web frontend
# Generated on $(date)

KAMAL_REGISTRY_PASSWORD=$KAMAL_REGISTRY_TOKEN
EOF

    echo -e "${GREEN}✅ Configuration files created:${NC}"
    echo "  - apps/api/config/deploy.yml (Kamal configuration)"
    echo "  - apps/api/.kamal/secrets (encrypted secrets)"
    echo "  - apps/web/config/deploy.yml (Frontend Kamal configuration)"
    echo "  - apps/web/.kamal/secrets (Frontend encrypted secrets)"
}

# Function to create test configuration in sample code folder
create_test_config() {
    echo -e "${BLUE}📝 Creating test configuration in sample code folder...${NC}"
    
    # Create the sample code directory if it doesn't exist
    mkdir -p "DEVELOPER_DOCUMENTATION/sample code"
    
    # Copy the generated deploy.yml files to the sample code folder
    cp apps/api/config/deploy.yml "DEVELOPER_DOCUMENTATION/sample code/api-deploy.yml.test"
    cp apps/web/config/deploy.yml "DEVELOPER_DOCUMENTATION/sample code/web-deploy.yml.test"
    
    echo -e "${GREEN}✅ Test configuration created:${NC}"
    echo "  - DEVELOPER_DOCUMENTATION/sample code/api-deploy.yml.test"
    echo "  - DEVELOPER_DOCUMENTATION/sample code/web-deploy.yml.test"
}

# Function to check if Kamal is installed
check_kamal() {
    if ! command -v kamal &> /dev/null; then
        echo -e "${RED}❌ Kamal is not installed. Please install it first:${NC}"
        echo "   gem install kamal"
        return 1
    fi
    return 0
}

# Function to run deployment
run_deployment() {
    echo ""
    echo -e "${BLUE}🚀 Starting deployment process...${NC}"
    
    if ! check_kamal; then
        return 1
    fi
    
    # Deploy API first (creates database and Redis accessories)
    echo ""
    echo -e "${BLUE}📦 Step 1: Deploying Rails API...${NC}"
    deploy_api "$1"
    if [ $? -ne 0 ]; then
        echo -e "${RED}❌ API deployment failed. Aborting.${NC}"
        return 1
    fi
    
    # Deploy web frontend
    echo ""
    echo -e "${BLUE}🌐 Step 2: Deploying Web Frontend...${NC}"
    deploy_web "$1"
    if [ $? -ne 0 ]; then
        echo -e "${RED}❌ Web frontend deployment failed. Aborting.${NC}"
        return 1
    fi
    
    echo ""
    echo -e "${GREEN}🎉 Complete deployment successful!${NC}"
    echo ""
    echo -e "${BLUE}📋 Your Asset Management System is now running:${NC}"
    echo "  🌐 Web Interface: http://$FRONTEND_DOMAIN"
    echo "  🔧 API: http://$FRONTEND_DOMAIN/api"
    echo "  🗄️  Database: PostgreSQL with Redis"
    echo ""
    echo -e "${YELLOW}💡 Default admin credentials:${NC}"
    echo "  Email: admin@example.com"
    echo "  Password: password"
    echo ""
    echo -e "${GREEN}✅ You can now access your Asset Management System!${NC}"
}

deploy_api() {
    echo ""
    echo -e "${BLUE}🔧 Deploying Rails API...${NC}"
    
    # Change to the API directory for deployment
    cd apps/api
    
    # Check if running in developer mode
    if [ "$1" = "--dev" ]; then
        echo ""
        echo -e "${BLUE}🔧 Developer Mode: Building and pushing API image...${NC}"
        echo -e "${YELLOW}⚠️  This will build and push new images to the registry.${NC}"
        
        echo ""
        echo -e "${BLUE}🔧 Running kamal setup (build and push)...${NC}"
        if ! kamal setup -c config/deploy.yml; then
            echo -e "${RED}❌ API setup failed. Please check your server configuration.${NC}"
            echo -e "${YELLOW}💡 Manual commands:${NC}"
            echo "   cd apps/api"
            echo "   kamal setup -c config/deploy.yml"
            echo "   kamal deploy -c config/deploy.yml"
            return 1
        fi
    else
        echo ""
        echo -e "${BLUE}📥 Customer Mode: Pulling existing API image...${NC}"
        echo -e "${GREEN}✅ Skipping build step - using pre-built images${NC}"
        
        # Validate that the image exists
        echo ""
        echo -e "${BLUE}🔍 Validating API image exists in registry...${NC}"
        if ! docker manifest inspect "$REGISTRY_SERVER/$REGISTRY_NAMESPACE/asset-management-system:latest" &> /dev/null; then
            echo -e "${RED}❌ API image not found in registry: $REGISTRY_SERVER/$REGISTRY_NAMESPACE/asset-management-system:latest${NC}"
            echo -e "${YELLOW}💡 This could mean:${NC}"
            echo "  - The image hasn't been built and pushed yet"
            echo "  - The registry URL is incorrect"
            echo "  - You need to contact the developer for a fresh image"
            return 1
        else
            echo -e "${GREEN}✅ API image found in registry${NC}"
        fi
        
        echo ""
        echo -e "${BLUE}🔧 Running kamal setup (pull only)...${NC}"
        if ! kamal setup -c config/deploy.yml --skip-push; then
            echo -e "${RED}❌ API setup failed. Please check your server configuration.${NC}"
            echo -e "${YELLOW}💡 Manual commands:${NC}"
            echo "   cd apps/api"
            echo "   kamal setup -c config/deploy.yml --skip-push"
            echo "   kamal deploy -c config/deploy.yml"
            return 1
        fi
    fi
    
    echo ""
    echo -e "${GREEN}✅ API deployment completed successfully!${NC}"
    echo ""
    echo -e "${BLUE}🔧 Running kamal deploy for API...${NC}"
    if ! kamal deploy -c config/deploy.yml; then
        echo -e "${RED}❌ API deploy failed. Please check your server configuration.${NC}"
        echo -e "${YELLOW}💡 Manual commands:${NC}"
        echo "   cd apps/api"
        echo "   kamal deploy -c config/deploy.yml"
        return 1
    fi
    
    echo ""
    echo -e "${GREEN}✅ API is now running with database and Redis accessories!${NC}"
    
    # Ensure deploy lock is released after API deployment
    echo "🔓 Releasing deploy lock after API deployment..."
    kamal lock release 2>/dev/null || true
    
    # Return to project root
    cd ../..
}

deploy_web() {
    echo ""
    echo -e "${BLUE}🔧 Deploying Web Frontend...${NC}"
    
    # Change to the web directory for deployment
    cd apps/web
    
    # Check if running in developer mode
    if [ "$1" = "--dev" ]; then
        echo ""
        echo -e "${BLUE}🔧 Developer Mode: Building and pushing web image...${NC}"
        echo -e "${YELLOW}⚠️  This will build and push new images to the registry.${NC}"
        
        echo ""
        echo -e "${BLUE}🔧 Running kamal setup (build and push)...${NC}"
        if ! kamal setup -c config/deploy.yml; then
            echo -e "${RED}❌ Web setup failed. Please check your server configuration.${NC}"
            echo -e "${YELLOW}💡 Manual commands:${NC}"
            echo "   cd apps/web"
            echo "   kamal setup -c config/deploy.yml"
            echo "   kamal deploy -c config/deploy.yml"
            return 1
        fi
    else
        echo ""
        echo -e "${BLUE}📥 Customer Mode: Pulling existing web image...${NC}"
        echo -e "${GREEN}✅ Skipping build step - using pre-built images${NC}"
        
        # Validate that the image exists
        echo ""
        echo -e "${BLUE}🔍 Validating web image exists in registry...${NC}"
        if ! docker manifest inspect "$REGISTRY_SERVER/$REGISTRY_NAMESPACE/asset-management-system-web:latest" &> /dev/null; then
            echo -e "${RED}❌ Web image not found in registry: $REGISTRY_SERVER/$REGISTRY_NAMESPACE/asset-management-system-web:latest${NC}"
            echo -e "${YELLOW}💡 This could mean:${NC}"
            echo "  - The image hasn't been built and pushed yet"
            echo "  - The registry URL is incorrect"
            echo "  - You need to contact the developer for a fresh image"
            return 1
        else
            echo -e "${GREEN}✅ Web image found in registry${NC}"
        fi
        
        echo ""
        echo -e "${BLUE}🔧 Running kamal setup (pull only)...${NC}"
        if ! kamal setup -c config/deploy.yml --skip-push; then
            echo -e "${RED}❌ Web setup failed. Please check your server configuration.${NC}"
            echo -e "${YELLOW}💡 Manual commands:${NC}"
            echo "   cd apps/web"
            echo "   kamal setup -c config/deploy.yml --skip-push"
            echo "   kamal deploy -c config/deploy.yml"
            return 1
        fi
    fi
    
    echo ""
    echo -e "${GREEN}✅ Web frontend deployment completed successfully!${NC}"
    echo ""
    echo -e "${BLUE}🔧 Running kamal deploy for web frontend...${NC}"
    if ! kamal deploy -c config/deploy.yml; then
        echo -e "${RED}❌ Web deploy failed. Please check your server configuration.${NC}"
        echo -e "${YELLOW}💡 Manual commands:${NC}"
        echo "   cd apps/web"
        echo "   kamal deploy -c config/deploy.yml"
        return 1
    fi
    
    echo ""
    echo -e "${GREEN}✅ Web frontend is now running and accessible!${NC}"
    
    # Ensure deploy lock is released after web deployment
    echo "🔓 Releasing deploy lock after web deployment..."
    kamal lock release 2>/dev/null || true
    
    # Return to project root
    cd ../..
}

# Function to check for existing containers and ask for cleanup
check_existing_containers() {
    echo ""
    echo -e "${BLUE}🔍 Checking for existing containers...${NC}"
    
    # Check for existing Docker state that could cause conflicts
    local api_containers=$(ssh -p "$SSH_PORT" "$SSH_USER@$SERVER_HOST" "docker ps -a --filter label=service=api --format '{{.Names}}' 2>/dev/null || echo ''" 2>/dev/null || echo "")
    local web_containers=$(ssh -p "$SSH_PORT" "$SSH_USER@$SERVER_HOST" "docker ps -a --filter label=service=web --format '{{.Names}}' 2>/dev/null || echo ''" 2>/dev/null || echo "")
    local frontend_containers=$(ssh -p "$SSH_PORT" "$SSH_USER@$SERVER_HOST" "docker ps -a --filter label=service=frontend --format '{{.Names}}' 2>/dev/null || echo ''" 2>/dev/null || echo "")
    local postgres_containers=$(ssh -p "$SSH_PORT" "$SSH_USER@$SERVER_HOST" "docker ps -a --filter label=service=api-postgres --format '{{.Names}}' 2>/dev/null || echo ''" 2>/dev/null || echo "")
    local redis_containers=$(ssh -p "$SSH_PORT" "$SSH_USER@$SERVER_HOST" "docker ps -a --filter label=service=api-redis --format '{{.Names}}' 2>/dev/null || echo ''" 2>/dev/null || echo "")
    
    # Check for volumes, networks, and images
    local existing_volumes=$(ssh -p "$SSH_PORT" "$SSH_USER@$SERVER_HOST" "docker volume ls --filter name=api --filter name=frontend --filter name=kamal --format '{{.Name}}' 2>/dev/null || echo ''" 2>/dev/null || echo "")
    local existing_networks=$(ssh -p "$SSH_PORT" "$SSH_USER@$SERVER_HOST" "docker network ls --filter name=kamal --format '{{.Name}}' 2>/dev/null || echo ''" 2>/dev/null || echo "")
    local existing_images=$(ssh -p "$SSH_PORT" "$SSH_USER@$SERVER_HOST" "docker images --filter reference='*asset-management*' --format '{{.Repository}}:{{.Tag}}' 2>/dev/null || echo ''" 2>/dev/null || echo "")
    local existing_directories=$(ssh -p "$SSH_PORT" "$SSH_USER@$SERVER_HOST" "ls -d /root/*postgres* /root/*redis* 2>/dev/null | head -5" 2>/dev/null || echo "")
    
    local has_existing=false
    
    if [ -n "$api_containers" ] || [ -n "$web_containers" ] || [ -n "$frontend_containers" ] || [ -n "$postgres_containers" ] || [ -n "$redis_containers" ] || [ -n "$existing_volumes" ] || [ -n "$existing_networks" ] || [ -n "$existing_images" ] || [ -n "$existing_directories" ]; then
        has_existing=true
        echo -e "${YELLOW}⚠️  Found existing Docker state that could cause conflicts:${NC}"
        
        if [ -n "$api_containers" ]; then
            echo "  📦 API containers: $api_containers"
        fi
        if [ -n "$web_containers" ]; then
            echo "  🌐 Web containers: $web_containers"
        fi
        if [ -n "$frontend_containers" ]; then
            echo "  🌐 Frontend containers: $frontend_containers"
        fi
        if [ -n "$postgres_containers" ]; then
            echo "  🗄️  PostgreSQL containers: $postgres_containers"
        fi
        if [ -n "$redis_containers" ]; then
            echo "  🔴 Redis containers: $redis_containers"
        fi
        if [ -n "$existing_volumes" ]; then
            echo "  💾 Existing volumes: $existing_volumes"
        fi
        if [ -n "$existing_networks" ]; then
            echo "  🌐 Existing networks: $existing_networks"
        fi
        if [ -n "$existing_images" ]; then
            echo "  🖼️  Existing images: $existing_images"
        fi
        if [ -n "$existing_directories" ]; then
            echo "  📁 Existing data directories: $existing_directories"
        fi
        
        echo ""
        echo -e "${YELLOW}This usually indicates a previous Asset Management System deployment.${NC}"
        echo -e "${YELLOW}To avoid password conflicts and ensure a clean deployment,${NC}"
        echo -e "${YELLOW}we recommend removing existing containers first.${NC}"
        echo -e "${GREEN}Note: Only containers tagged with our service labels will be affected.${NC}"
        echo ""
        
        while true; do
            echo "Choose cleanup option:"
            echo "1) Remove only Asset Management System containers (recommended)"
            echo "2) Skip cleanup (may cause deployment issues)"
            echo "3) Remove all Docker objects (containers, images, volumes, networks) but keep Docker installed"
            echo -e "${RED}4) Complete server wipe - Remove Docker entirely and reinstall (nuclear option)${NC}"
            read -p "Enter choice [1-4]: " cleanup_choice
            case $cleanup_choice in
                1)
                    echo ""
                    echo -e "${BLUE}🧹 Cleaning up existing Asset Management System containers...${NC}"
                    
                    # Remove existing containers (only those with our specific service labels)
                    if [ -n "$api_containers" ]; then
                        echo "  Removing Asset Management System API containers..."
                        ssh -p "$SSH_PORT" "$SSH_USER@$SERVER_HOST" "docker stop $api_containers 2>/dev/null || true; docker rm $api_containers 2>/dev/null || true"
                    fi
                    if [ -n "$web_containers" ]; then
                        echo "  Removing Asset Management System Web containers..."
                        ssh -p "$SSH_PORT" "$SSH_USER@$SERVER_HOST" "docker stop $web_containers 2>/dev/null || true; docker rm $web_containers 2>/dev/null || true"
                    fi
                    if [ -n "$frontend_containers" ]; then
                        echo "  Removing Asset Management System Frontend containers..."
                        ssh -p "$SSH_PORT" "$SSH_USER@$SERVER_HOST" "docker stop $frontend_containers 2>/dev/null || true; docker rm $frontend_containers 2>/dev/null || true"
                    fi
                    if [ -n "$postgres_containers" ]; then
                        echo "  Removing Asset Management System PostgreSQL containers..."
                        ssh -p "$SSH_PORT" "$SSH_USER@$SERVER_HOST" "docker stop $postgres_containers 2>/dev/null || true; docker rm $postgres_containers 2>/dev/null || true"
                    fi
                    if [ -n "$redis_containers" ]; then
                        echo "  Removing Asset Management System Redis containers..."
                        ssh -p "$SSH_PORT" "$SSH_USER@$SERVER_HOST" "docker stop $redis_containers 2>/dev/null || true; docker rm $redis_containers 2>/dev/null || true"
                    fi
                    
                    # Remove existing volumes and networks
                    if [ -n "$existing_volumes" ]; then
                        echo "  Removing Asset Management System volumes..."
                        ssh -p "$SSH_PORT" "$SSH_USER@$SERVER_HOST" "docker volume rm $existing_volumes 2>/dev/null || true"
                    fi
                    if [ -n "$existing_networks" ]; then
                        echo "  Removing Asset Management System networks..."
                        ssh -p "$SSH_PORT" "$SSH_USER@$SERVER_HOST" "docker network rm $existing_networks 2>/dev/null || true"
                    fi
                    
                    # Remove existing data directories to ensure fresh database initialization
                    echo "  Removing Asset Management System data directories..."
                    ssh -p "$SSH_PORT" "$SSH_USER@$SERVER_HOST" "rm -rf /root/api-postgres /root/api-redis /root/frontend-postgres /root/frontend-redis 2>/dev/null || true"
                    ssh -p "$SSH_PORT" "$SSH_USER@$SERVER_HOST" "find /root -name '*postgres*' -type d -exec rm -rf {} + 2>/dev/null || true"
                    ssh -p "$SSH_PORT" "$SSH_USER@$SERVER_HOST" "find /root -name '*redis*' -type d -exec rm -rf {} + 2>/dev/null || true"
                    
                    echo -e "${GREEN}✅ Cleanup completed successfully!${NC}"
                    break
                    ;;
                2)
                    echo ""
                    echo -e "${YELLOW}⚠️  Proceeding with existing containers.${NC}"
                    echo -e "${YELLOW}Note: This may cause deployment issues if passwords don't match.${NC}"
                    break
                    ;;
                3)
                    echo ""
                    echo -e "${BLUE}🧹 Removing all Docker objects but keeping Docker installed...${NC}"
                    
                    # Stop all containers
                    echo "  Stopping all Docker containers..."
                    ssh -p "$SSH_PORT" "$SSH_USER@$SERVER_HOST" "docker stop \$(docker ps -aq) 2>/dev/null || true"
                    
                    # Remove all containers
                    echo "  Removing all Docker containers..."
                    ssh -p "$SSH_PORT" "$SSH_USER@$SERVER_HOST" "docker rm \$(docker ps -aq) 2>/dev/null || true"
                    
                    # Remove all images
                    echo "  Removing all Docker images..."
                    ssh -p "$SSH_PORT" "$SSH_USER@$SERVER_HOST" "docker rmi \$(docker images -aq) 2>/dev/null || true"
                    
                    # Remove all volumes
                    echo "  Removing all Docker volumes..."
                    ssh -p "$SSH_PORT" "$SSH_USER@$SERVER_HOST" "docker volume rm \$(docker volume ls -q) 2>/dev/null || true"
                    
                    # Remove all networks
                    echo "  Removing all Docker networks..."
                    ssh -p "$SSH_PORT" "$SSH_USER@$SERVER_HOST" "docker network rm \$(docker network ls -q) 2>/dev/null || true"
                    
                    # Remove Docker system
                    echo "  Cleaning up Docker system..."
                    ssh -p "$SSH_PORT" "$SSH_USER@$SERVER_HOST" "docker system prune -af --volumes 2>/dev/null || true"
                    
                    # Remove all persistent data directories
                    echo "  Removing all persistent data directories..."
                    ssh -p "$SSH_PORT" "$SSH_USER@$SERVER_HOST" "rm -rf /root/api-postgres /root/api-redis /root/frontend-postgres /root/frontend-redis /root/*-postgres /root/*-redis 2>/dev/null || true"
                    ssh -p "$SSH_PORT" "$SSH_USER@$SERVER_HOST" "rm -rf /var/lib/docker/volumes/* 2>/dev/null || true"
                    ssh -p "$SSH_PORT" "$SSH_USER@$SERVER_HOST" "find /root -name '*postgres*' -type d -exec rm -rf {} + 2>/dev/null || true"
                    ssh -p "$SSH_PORT" "$SSH_USER@$SERVER_HOST" "find /root -name '*redis*' -type d -exec rm -rf {} + 2>/dev/null || true"
                    
                    echo -e "${GREEN}✅ All Docker objects removed successfully!${NC}"
                    echo -e "${GREEN}Docker remains installed and ready for deployment.${NC}"
                    break
                    ;;
                4)
                    echo ""
                    echo -e "${RED}⚠️  NUCLEAR OPTION: Complete server wipe selected!${NC}"
                    echo -e "${RED}This will remove Docker entirely and reinstall it.${NC}"
                    echo -e "${RED}ALL Docker containers, images, volumes, networks, and persistent storage will be lost!${NC}"
                    echo ""
                    read -p "Are you absolutely sure you want to proceed? Type 'YES' to confirm: " confirm_wipe
                    if [ "$confirm_wipe" = "YES" ]; then
                        echo ""
                        echo -e "${BLUE}🧹 Performing complete server wipe...${NC}"
                        
                        # Stop all containers
                        echo "  Stopping all Docker containers..."
                        ssh -p "$SSH_PORT" "$SSH_USER@$SERVER_HOST" "docker stop \$(docker ps -aq) 2>/dev/null || true"
                        
                        # Remove all containers
                        echo "  Removing all Docker containers..."
                        ssh -p "$SSH_PORT" "$SSH_USER@$SERVER_HOST" "docker rm \$(docker ps -aq) 2>/dev/null || true"
                        
                        # Remove all images
                        echo "  Removing all Docker images..."
                        ssh -p "$SSH_PORT" "$SSH_USER@$SERVER_HOST" "docker rmi \$(docker images -aq) 2>/dev/null || true"
                        
                        # Remove all volumes
                        echo "  Removing all Docker volumes..."
                        ssh -p "$SSH_PORT" "$SSH_USER@$SERVER_HOST" "docker volume rm \$(docker volume ls -q) 2>/dev/null || true"
                        
                        # Remove all networks
                        echo "  Removing all Docker networks..."
                        ssh -p "$SSH_PORT" "$SSH_USER@$SERVER_HOST" "docker network rm \$(docker network ls -q) 2>/dev/null || true"
                        
                        # Remove Docker system
                        echo "  Removing Docker system..."
                        ssh -p "$SSH_PORT" "$SSH_USER@$SERVER_HOST" "docker system prune -af --volumes 2>/dev/null || true"
                        
                        # Remove all persistent data directories
                        echo "  Removing all persistent data directories..."
                        ssh -p "$SSH_PORT" "$SSH_USER@$SERVER_HOST" "rm -rf /root/api-postgres /root/api-redis /root/frontend-postgres /root/frontend-redis /root/*-postgres /root/*-redis 2>/dev/null || true"
                        ssh -p "$SSH_PORT" "$SSH_USER@$SERVER_HOST" "rm -rf /var/lib/docker/volumes/* 2>/dev/null || true"
                        ssh -p "$SSH_PORT" "$SSH_USER@$SERVER_HOST" "find /root -name '*postgres*' -type d -exec rm -rf {} + 2>/dev/null || true"
                        ssh -p "$SSH_PORT" "$SSH_USER@$SERVER_HOST" "find /root -name '*redis*' -type d -exec rm -rf {} + 2>/dev/null || true"
                        
                        # Uninstall Docker
                        echo "  Uninstalling Docker..."
                        ssh -p "$SSH_PORT" "$SSH_USER@$SERVER_HOST" "apt-get remove -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin 2>/dev/null || true"
                        ssh -p "$SSH_PORT" "$SSH_USER@$SERVER_HOST" "apt-get purge -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin 2>/dev/null || true"
                        ssh -p "$SSH_PORT" "$SSH_USER@$SERVER_HOST" "rm -rf /var/lib/docker /var/lib/containerd /etc/docker 2>/dev/null || true"
                        
                        # Reinstall Docker using kamal setup
                        echo "  Reinstalling Docker using kamal setup..."
                        echo "  Note: Docker will be installed automatically when kamal setup runs"
                        
                        echo -e "${GREEN}✅ Complete server wipe and Docker reinstall completed!${NC}"
                        break
                    else
                        echo -e "${YELLOW}Server wipe cancelled.${NC}"
                        continue
                    fi
                    ;;
                * )
                    echo -e "${YELLOW}Please enter 1, 2, or 3.${NC}"
                    ;;
            esac
        done
    else
        echo -e "${GREEN}✅ No existing Asset Management System containers found. Ready for fresh deployment.${NC}"
    fi
}

# Function to show manual commands
show_manual_commands() {
    echo ""
    echo -e "${BLUE}📋 Manual Deployment Commands:${NC}"
    echo "============================="
    echo ""
    echo "To deploy manually, run these commands:"
    echo ""
    echo -e "${YELLOW}Step 1: Deploy Rails API${NC}"
    echo "1. cd apps/api"
    echo "2. kamal setup -c config/deploy.yml"
    echo "3. kamal deploy -c config/deploy.yml"
    echo ""
    echo -e "${YELLOW}Step 2: Deploy Web Frontend${NC}"
    echo "4. cd ../web"
    echo "5. kamal setup -c config/deploy.yml"
    echo "6. kamal deploy -c config/deploy.yml"
    echo ""
    echo -e "${YELLOW}Useful commands:${NC}"
    echo "  kamal app logs -c config/deploy.yml     - View application logs"
    echo "  kamal app restart -c config/deploy.yml  - Restart the application"
    echo "  kamal remove -c config/deploy.yml       - Remove the deployment"
    echo ""
    echo -e "${GREEN}After deployment, access your system at: http://$FRONTEND_DOMAIN${NC}"
    echo -e "${GREEN}API will be available at: http://$FRONTEND_DOMAIN/api${NC}"
    echo ""
}

# Function to perform nuclear server wipe
nuclear_server_wipe() {
    echo ""
    echo -e "${RED}🚨 NUCLEAR OPTION: Complete server wipe in progress...${NC}"
    echo -e "${RED}This will remove Docker entirely and reinstall it.${NC}"
    echo -e "${RED}ALL Docker containers, images, volumes, networks, and persistent storage will be lost!${NC}"
    echo ""
    
    # Stop all containers
    echo "  Stopping all Docker containers..."
    ssh -p "$SSH_PORT" "$SSH_USER@$SERVER_HOST" "docker stop \$(docker ps -aq) 2>/dev/null || true"
    
    # Remove all containers
    echo "  Removing all Docker containers..."
    ssh -p "$SSH_PORT" "$SSH_USER@$SERVER_HOST" "docker rm \$(docker ps -aq) 2>/dev/null || true"
    
    # Remove all images
    echo "  Removing all Docker images..."
    ssh -p "$SSH_PORT" "$SSH_USER@$SERVER_HOST" "docker rmi \$(docker images -aq) 2>/dev/null || true"
    
    # Remove all volumes
    echo "  Removing all Docker volumes..."
    ssh -p "$SSH_PORT" "$SSH_USER@$SERVER_HOST" "docker volume rm \$(docker volume ls -q) 2>/dev/null || true"
    
    # Remove all networks
    echo "  Removing all Docker networks..."
    ssh -p "$SSH_PORT" "$SSH_USER@$SERVER_HOST" "docker network rm \$(docker network ls -q) 2>/dev/null || true"
    
    # Remove Docker system
    echo "  Removing Docker system..."
    ssh -p "$SSH_PORT" "$SSH_USER@$SERVER_HOST" "docker system prune -af --volumes 2>/dev/null || true"
    
    # Remove all persistent data directories
    echo "  Removing all persistent data directories..."
    ssh -p "$SSH_PORT" "$SSH_USER@$SERVER_HOST" "rm -rf /root/api-postgres /root/api-redis /root/frontend-postgres /root/frontend-redis /root/*-postgres /root/*-redis 2>/dev/null || true"
    ssh -p "$SSH_PORT" "$SSH_USER@$SERVER_HOST" "rm -rf /var/lib/docker/volumes/* 2>/dev/null || true"
    ssh -p "$SSH_PORT" "$SSH_USER@$SERVER_HOST" "find /root -name '*postgres*' -type d -exec rm -rf {} + 2>/dev/null || true"
    ssh -p "$SSH_PORT" "$SSH_USER@$SERVER_HOST" "find /root -name '*redis*' -type d -exec rm -rf {} + 2>/dev/null || true"
    
    # Uninstall Docker
    echo "  Uninstalling Docker..."
    ssh -p "$SSH_PORT" "$SSH_USER@$SERVER_HOST" "apt-get remove -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin 2>/dev/null || true"
    ssh -p "$SSH_PORT" "$SSH_USER@$SERVER_HOST" "apt-get purge -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin 2>/dev/null || true"
    ssh -p "$SSH_PORT" "$SSH_USER@$SERVER_HOST" "rm -rf /var/lib/docker /var/lib/containerd /etc/docker 2>/dev/null || true"
    
    # Reinstall Docker using kamal setup
    echo "  Docker will be reinstalled automatically when kamal setup runs..."
    
    echo -e "${GREEN}✅ Nuclear server wipe completed!${NC}"
    echo -e "${GREEN}Server is now ready for fresh deployment.${NC}"
}

# Function to select setup type
select_setup_type() {
    echo ""
    echo -e "${BLUE}🔧 Setup Type Selection${NC}"
    echo "========================"
    echo "Please select the type of setup you want to perform:"
    echo ""
    echo "1) Standard Customer Deployment (pull existing images)"
    echo "2) Developer Deployment (build and push new images)"
    echo "3) Developer Deployment with Preset Configuration (--dev -p)"
    echo -e "${RED}4) Nuclear Option - Complete server wipe and fresh deployment${NC}"
    echo ""
    
    while true; do
        read -p "Enter choice [1-4]: " setup_choice
        case $setup_choice in
            1)
                echo -e "${GREEN}✅ Selected: Standard Customer Deployment${NC}"
                SETUP_TYPE="customer"
                DEV_MODE=""
                PRESET_MODE=""
                break
                ;;
            2)
                echo -e "${GREEN}✅ Selected: Developer Deployment${NC}"
                SETUP_TYPE="developer"
                DEV_MODE="--dev"
                PRESET_MODE=""
                break
                ;;
            3)
                echo -e "${GREEN}✅ Selected: Developer Deployment with Preset Configuration${NC}"
                SETUP_TYPE="developer_preset"
                DEV_MODE="--dev"
                PRESET_MODE="-p"
                break
                ;;
            4)
                echo -e "${RED}⚠️  Selected: Nuclear Option - Complete Server Wipe${NC}"
                echo -e "${RED}This will completely wipe the server and start fresh!${NC}"
                read -p "Are you absolutely sure? Type 'YES' to confirm: " confirm_nuclear
                if [ "$confirm_nuclear" = "YES" ]; then
                    SETUP_TYPE="nuclear"
                    DEV_MODE="--dev"
                    PRESET_MODE=""
                    echo -e "${RED}✅ Nuclear option confirmed${NC}"
                    break
                else
                    echo -e "${YELLOW}Nuclear option cancelled. Please select another option.${NC}"
                    continue
                fi
                ;;
            *)
                echo -e "${YELLOW}Please enter 1, 2, 3, or 4.${NC}"
                ;;
        esac
    done
}

# Main script logic
main() {
    # Check for help flag
    if [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
        echo "Usage: $0 [--dev] [-p]"
        echo ""
        echo "Options:"
        echo "  --dev    Developer mode: Build and push images to registry"
        echo "  -p       Preset mode: Use configuration from .env.setup_kamal file"
        echo "           (skips interactive configuration questions)"
        echo ""
        echo "Examples:"
        echo "  $0              # Interactive setup with customer mode"
        echo "  $0 --dev        # Interactive setup with developer mode"
        echo "  $0 --dev -p     # Non-interactive setup with preset configuration"
        echo ""
        echo "Setup Types (selected interactively if no flags provided):"
        echo "  1) Standard Customer Deployment (pull existing images)"
        echo "  2) Developer Deployment (build and push new images)"  
        echo "  3) Developer Deployment with Preset Configuration"
        echo "  4) Nuclear Option - Complete server wipe and fresh deployment"
        exit 0
    fi
    
    # Check if we're in the right directory
    if [ ! -f "apps/api/Gemfile" ]; then
        echo -e "${RED}Error: This script must be run from the project root directory.${NC}"
        echo "Please cd to the directory containing apps/api/Gemfile"
        exit 1
    fi

    # Parse command line arguments
    DEV_MODE=""
    PRESET_MODE=""
    SETUP_TYPE=""
    
    # Check for --dev -p combination
    if [ "$1" = "--dev" ] && [ "$2" = "-p" ]; then
        DEV_MODE="--dev"
        PRESET_MODE="-p"
        SETUP_TYPE="developer_preset"
        echo -e "${BLUE}🚀 Developer mode with preset configuration enabled${NC}"
        load_env_config
    elif [ "$1" = "--dev" ]; then
        DEV_MODE="--dev"
        SETUP_TYPE="developer"
        echo -e "${BLUE}🚀 Developer mode enabled${NC}"
    elif [ "$1" = "-p" ]; then
        echo -e "${RED}❌ Error: -p flag requires --dev flag${NC}"
        echo "Usage: $0 --dev -p"
        exit 1
    else
        # No flags provided, show interactive setup type selection
        select_setup_type
    fi

    # Load configuration based on setup type
    if [ "$SETUP_TYPE" = "developer_preset" ]; then
        # Configuration already loaded by load_env_config above
        :
    else
        # Collect configuration interactively
        collect_config "$DEV_MODE" "$PRESET_MODE"
    fi
    
    # Show summary and get confirmation (skip in preset mode)
    if [ "$PRESET_MODE" = "-p" ]; then
        echo -e "${GREEN}✅ Using preset configuration, skipping confirmation${NC}"
        show_summary
    else
        while true; do
            show_summary
            read -p "Is this correct? (y/n/e for edit): " confirm
            
            case $confirm in
                [Yy]* )
                    break
                    ;;
                [Nn]* )
                    echo -e "${YELLOW}Setup cancelled.${NC}"
                    exit 0
                    ;;
                [Ee]* )
                    echo -e "${BLUE}Re-running configuration with current values as defaults...${NC}"
                    collect_config "$DEV_MODE" "$PRESET_MODE"
                    ;;
                * )
                    echo -e "${YELLOW}Please answer y (yes), n (no), or e (edit).${NC}"
                    ;;
            esac
        done
    fi
    
    # Handle nuclear option
    if [ "$SETUP_TYPE" = "nuclear" ]; then
        echo -e "${RED}🚨 Executing Nuclear Option - Complete Server Wipe${NC}"
        # Force cleanup option 4 (complete server wipe)
        nuclear_server_wipe
    else
        # Check for existing containers and offer cleanup
        check_existing_containers
    fi
    
    # Generate secrets
    get_rails_master_key
    generate_jwt_secret
    
    # Create configuration files
    create_config_files
    
    # Create test configuration
    create_test_config
    
    echo ""
    echo -e "${YELLOW}🔒 Security Notes:${NC}"
    echo "  - .kamal/secrets contains sensitive data - never commit to git"
    echo "  - All secrets are stored securely in the .kamal/secrets file"
    echo "  - No environment variables need to be set manually"
    echo ""
    
    # Ask if user wants to deploy now (skip in preset mode)
    if [ "$PRESET_MODE" = "-p" ]; then
        echo -e "${GREEN}✅ Preset mode: Starting deployment automatically${NC}"
        run_deployment "$DEV_MODE"
    else
        echo -e "${BLUE}🚀 Ready to deploy now? (y/n):${NC}"
        read -p "" deploy_now
        
        case $deploy_now in
            [Yy]* )
                echo ""
                echo -e "${YELLOW}⚠️  Important: This will attempt to deploy using your registry token.${NC}"
                echo "If you encounter authentication errors, it means:"
                echo "  - Your registry token is invalid or expired"
                echo "  - You need a fresh token from the developer"
                echo "  - The token doesn't have the correct permissions"
                echo ""
                read -p "Continue with deployment? (y/n): " confirm_deploy
                case $confirm_deploy in
                    [Yy]* )
                        run_deployment "$DEV_MODE"
                        ;;
                    [Nn]* )
                        show_manual_commands
                        ;;
                    * )
                        echo -e "${YELLOW}Assuming no. Showing manual commands...${NC}"
                        show_manual_commands
                        ;;
                esac
                ;;
            [Nn]* )
                show_manual_commands
                ;;
            * )
                echo -e "${YELLOW}Assuming no. Showing manual commands...${NC}"
                show_manual_commands
                ;;
        esac
    fi
    
    echo ""
    echo -e "${GREEN}🎉 Setup complete!${NC}"
}

# Run main function
main "$@"