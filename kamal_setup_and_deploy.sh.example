#!/bin/bash
set -e

# =============================================================================
# EXAMPLE KAMAL SETUP AND DEPLOYMENT SCRIPT
# =============================================================================
# 
# This is an example script for deploying Rails API + Next.js Frontend using Kamal.
# 
# IMPORTANT: This is a template file with placeholder values.
# Before using this script:
# 1. Copy this file to a new name (e.g., setup_kamal.sh)
# 2. Replace all placeholder values with your actual configuration:
#    - your-registry.com ‚Üí your actual registry URL
#    - your-namespace ‚Üí your actual registry namespace
#    - your-app-api ‚Üí your actual API image name
#    - your-app-web ‚Üí your actual web image name
#    - yourdomain.com ‚Üí your actual domain
#    - your-secure-password ‚Üí your actual secure password
# 3. Make the script executable: chmod +x setup_kamal.sh
# 4. Run the script: ./setup_kamal.sh
#
# This script handles the complete deployment workflow from configuration to deployment
# =============================================================================

echo "üöÄ Kamal Deployment Setup for Rails API + Next.js Frontend"
echo "========================================================="

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Function to collect user input with default values
collect_input() {
    local prompt="$1"
    local default="$2"
    local var_name="$3"
    
    if [ -n "$default" ]; then
        read -p "$prompt [$default]: " input
        eval "$var_name=\"\${input:-$default}\""
    else
        read -p "$prompt: " input
        eval "$var_name=\"$input\""
    fi
}

# Function to show configuration summary
show_summary() {
    echo ""
    echo -e "${BLUE}üìã Configuration Summary${NC}"
    echo "========================"
    echo "Deployment Server: $SERVER_HOST"
    echo "SSH User: $SSH_USER"
    echo "SSH Port: $SSH_PORT"
    echo "Registry: $REGISTRY_URL (pre-built images)"
    echo "Registry User: $REGISTRY_USERNAME"
    echo "Database: $DATABASE_NAME"
    echo "Storage: Local (persistent host volume)"
    echo "Application Domain: $FRONTEND_DOMAIN"
    echo "API Path: /api (same domain)"
    echo "SSL Email: $SSL_EMAIL"
    echo "Environment: $RAILS_ENV"
    echo "Web Concurrency: $WEB_CONCURRENCY"
    echo "Max Threads: $RAILS_MAX_THREADS"
    echo "Build Platform: $BUILD_ARCH"
    echo "Logging: $DETAILED_LOGGING ($LOG_LEVEL)"
    echo ""
}

# Function to collect all configuration
collect_config() {
    local dev_mode="$1"
    
    # DNS Requirements Explanation
    echo ""
    echo -e "${BLUE}üåê DNS Setup Requirements${NC}"
    echo "============================="
    echo "This application requires TWO separate domain names:"
    echo ""
    echo "1. Application Domain: Where users access the web interface and API"
    echo "   Example: assets.yourdomain.com"
    echo "   - Web interface: https://assets.yourdomain.com"
    echo "   - API endpoints: https://assets.yourdomain.com/api"
    echo ""
    echo "2. Server Domain: The server where Docker runs and hosts the application"
    echo "   Example: cloud.yourdomain.com (or use IP address)"
    echo ""
    echo -e "${YELLOW}üìã You need to create TWO DNS A records pointing to your server:${NC}"
    echo "   - Application domain ‚Üí Your server IP"
    echo "   - Server domain ‚Üí Your server IP"
    echo ""
    echo "Example DNS records:"
    echo "   assets.yourdomain.com     A    YOUR_SERVER_IP"
    echo "   cloud.yourdomain.com      A    YOUR_SERVER_IP"
    echo ""
    read -p "Press Enter to continue with domain configuration..."
    echo ""

    # Domain Configuration
    echo -e "${BLUE}üåê Domain Configuration${NC}"
    echo "=========================="
    
    # Function to validate domain name
    validate_domain() {
        local domain="$1"
        echo -e "${BLUE}üîç Validating domain name: $domain${NC}"
        
        if command -v nslookup &> /dev/null; then
            if nslookup "$domain" &> /dev/null; then
                echo -e "${GREEN}‚úÖ Domain resolves successfully${NC}"
                return 0
            else
                echo -e "${RED}‚ùå Domain does not resolve${NC}"
                return 1
            fi
        elif command -v dig &> /dev/null; then
            if dig +short "$domain" | grep -q .; then
                echo -e "${GREEN}‚úÖ Domain resolves successfully${NC}"
                return 0
            else
                echo -e "${RED}‚ùå Domain does not resolve${NC}"
                return 1
            fi
        else
            echo -e "${YELLOW}‚ö†Ô∏è  Cannot validate domain (nslookup/dig not available)${NC}"
            return 0
        fi
    }
    
    # Collect frontend domain name with validation
    while true; do
        collect_input "Frontend domain name (e.g., assets.yourdomain.com)" "" "FRONTEND_DOMAIN"
        
        if validate_domain "$FRONTEND_DOMAIN"; then
            break
        else
            echo ""
            echo -e "${YELLOW}‚ö†Ô∏è  The domain '$FRONTEND_DOMAIN' does not resolve to an IP address.${NC}"
            echo "This could mean:"
            echo "  - The domain name is misspelled"
            echo "  - DNS records haven't been set up yet"
            echo "  - The domain is not pointing to your server"
            echo ""
            read -p "Do you want to edit the domain name? (y/n): " edit_domain
            case $edit_domain in
                [Yy]* )
                    echo "Please enter the correct domain name:"
                    continue
                    ;;
                [Nn]* )
                    echo -e "${YELLOW}‚ö†Ô∏è  Proceeding with unresolved domain. Make sure DNS is configured before deployment.${NC}"
                    break
                    ;;
                * )
                    echo -e "${YELLOW}Please answer y (yes) or n (no).${NC}"
                    ;;
            esac
        fi
    done
    
    # API will use the same domain as frontend with /api path prefix
    API_DOMAIN="$FRONTEND_DOMAIN"
    echo -e "${GREEN}‚úÖ API will be accessible at: http://$API_DOMAIN/api${NC}"

    # Deployment Server Configuration
    echo ""
    echo -e "${BLUE}üñ•Ô∏è  Deployment Server Configuration${NC}"
    echo "====================================="
    echo "This is the server where the application will be deployed."
    echo "It should be a Linux server (Ubuntu/CentOS/Debian)."
    echo "Docker will be installed automatically by Kamal if not present."
    echo "The server will host both the frontend and API applications."
    echo ""
    collect_input "Deployment Server hostname or IP address" "" "SERVER_HOST"
    collect_input "SSH username" "root" "SSH_USER"
    collect_input "SSH port" "22" "SSH_PORT"

    echo ""
    echo -e "${BLUE}üê≥ Docker Registry Configuration${NC}"
    echo "=================================="
    echo "Using pre-built images from your container registry"
    REGISTRY_SERVER="your-registry.com"
    REGISTRY_NAMESPACE="your-namespace"
    REGISTRY_USERNAME="your-registry-username"
    echo "Registry Server: $REGISTRY_SERVER"
    echo "Registry Namespace: $REGISTRY_NAMESPACE"
    echo "Registry Username: $REGISTRY_USERNAME"
    echo ""
    
    # Check if running in developer mode
    if [ "$dev_mode" = "--dev" ]; then
        echo -e "${BLUE}üîß Developer Mode: Building and pushing images${NC}"
        
        # First, try to load the token from shell profile if not already set
        if [ -z "$KAMAL_REGISTRY_TOKEN" ]; then
            if [ -n "$ZSH_VERSION" ]; then
                source ~/.zshrc 2>/dev/null || true
            elif [ -n "$BASH_VERSION" ]; then
                source ~/.bashrc 2>/dev/null || true
            fi
        fi
        
        # Check for existing environment variable
        if [ -n "$KAMAL_REGISTRY_TOKEN" ]; then
            echo -e "${GREEN}‚úÖ Using existing KAMAL_REGISTRY_TOKEN from environment variable${NC}"
            echo "Token: ${KAMAL_REGISTRY_TOKEN:0:20}...${KAMAL_REGISTRY_TOKEN: -10}"
            echo ""
            read -p "Want to use a different token? (y/n): " change_token
            case $change_token in
                [Yy]* )
                    collect_input "Enter new DigitalOcean Registry Access Token" "" "KAMAL_REGISTRY_TOKEN"
                    read -p "Save this token to KAMAL_REGISTRY_TOKEN environment variable? (y/n): " save_token
                    case $save_token in
                        [Yy]* )
                            echo "export KAMAL_REGISTRY_TOKEN=\"$KAMAL_REGISTRY_TOKEN\"" >> ~/.bashrc
                            echo "export KAMAL_REGISTRY_TOKEN=\"$KAMAL_REGISTRY_TOKEN\"" >> ~/.zshrc
                            echo -e "${GREEN}‚úÖ Token saved to environment variables${NC}"
                            
                            # Export in current session
                            export KAMAL_REGISTRY_TOKEN="$KAMAL_REGISTRY_TOKEN"
                            echo -e "${GREEN}‚úÖ Token loaded in current session${NC}"
                            
                            # Also source the shell profile to ensure it's available
                            if [ -n "$ZSH_VERSION" ]; then
                                source ~/.zshrc 2>/dev/null || true
                            elif [ -n "$BASH_VERSION" ]; then
                                source ~/.bashrc 2>/dev/null || true
                            fi
                            ;;
                    esac
                    ;;
                [Nn]* )
                    echo "Continuing with existing token..."
                    ;;
            esac
        else
            collect_input "Enter your Registry Access Token (read/write for building)" "" "KAMAL_REGISTRY_TOKEN"
            read -p "Save this token to KAMAL_REGISTRY_TOKEN environment variable? (y/n): " save_token
            case $save_token in
                [Yy]* )
                    echo "export KAMAL_REGISTRY_TOKEN=\"$KAMAL_REGISTRY_TOKEN\"" >> ~/.bashrc
                    echo "export KAMAL_REGISTRY_TOKEN=\"$KAMAL_REGISTRY_TOKEN\"" >> ~/.zshrc
                    echo -e "${GREEN}‚úÖ Token saved to environment variables${NC}"
                    
                    # Export in current session
                    export KAMAL_REGISTRY_TOKEN="$KAMAL_REGISTRY_TOKEN"
                    echo -e "${GREEN}‚úÖ Token loaded in current session${NC}"
                    
                    # Also source the shell profile to ensure it's available
                    if [ -n "$ZSH_VERSION" ]; then
                        source ~/.zshrc 2>/dev/null || true
                    elif [ -n "$BASH_VERSION" ]; then
                        source ~/.bashrc 2>/dev/null || true
                    fi
                    ;;
            esac
        fi
    else
        echo "You need a read-only access token to pull the pre-built images."
        echo "Contact your administrator to obtain your registry access token."
        collect_input "Registry Access Token (contact administrator for access)" "" "KAMAL_REGISTRY_TOKEN"
    fi

    echo ""
    echo -e "${BLUE}üóÑÔ∏è Database Configuration${NC}"
    echo "============================="
    collect_input "Create database password" "" "POSTGRES_PASSWORD"
    collect_input "Database name" "your_app_production" "DATABASE_NAME"

    echo ""
    echo -e "${BLUE}üì¶ Storage Configuration${NC}"
    echo "============================="
    echo "Using local storage - files will be stored directly on the server"
    echo "with persistent host storage volume."
    echo ""
    echo "Note: S3-compatible storage can be configured after deployment"
    echo "through the application's admin interface."
    
    STORAGE_TYPE="local"

    echo ""
    echo -e "${BLUE}üîê SSL Configuration${NC}"
    echo "======================"
    echo "The system uses Let's Encrypt SSL certificates for secure HTTPS connections."
    echo "Let's Encrypt requires an email address to send notifications about certificate"
    echo "renewals and important security updates."
    collect_input "Email for Let's Encrypt SSL notifications" "" "SSL_EMAIL"

    echo ""
    echo -e "${BLUE}‚öôÔ∏è Application Configuration${NC}"
    echo "==============================="
    collect_input "Application environment" "production" "RAILS_ENV"
    collect_input "Web concurrency (number of workers)" "2" "WEB_CONCURRENCY"
    collect_input "Max threads per worker" "5" "RAILS_MAX_THREADS"
    
    echo ""
    echo -e "${BLUE}üèóÔ∏è Build Platform Configuration${NC}"
    echo "=================================="
    echo "Choose the target deployment platform:"
    echo "1) AMD64 (x86_64) - Standard servers, most cloud providers"
    echo "2) ARM64 (aarch64) - Apple Silicon, ARM-based servers"
    read -p "Enter choice [1-2]: " platform_choice
    
    case $platform_choice in
        1)
            BUILD_ARCH="amd64"
            echo "Using AMD64 platform - compatible with most servers"
            ;;
        2)
            BUILD_ARCH="arm64"
            echo "Using ARM64 platform - for Apple Silicon and ARM servers"
            echo -e "${YELLOW}Note: ARM64 support is experimental. Use AMD64 for production deployments.${NC}"
            ;;
        *)
            echo -e "${RED}Invalid choice. Defaulting to AMD64.${NC}"
            BUILD_ARCH="amd64"
            ;;
    esac

    echo ""
    echo -e "${BLUE}üìä Monitoring & Logging${NC}"
    echo "============================="
    collect_input "Enable detailed logging (true/false)" "true" "DETAILED_LOGGING"
    collect_input "Log level (debug/info/warn/error)" "info" "LOG_LEVEL"
}

# Function to get Rails master key
get_rails_master_key() {
    echo -e "${BLUE}üîë Getting Rails master key...${NC}"
    if [ -f "apps/api/config/master.key" ]; then
        RAILS_MASTER_KEY=$(cat apps/api/config/master.key | tr -d '\n')
        echo -e "${GREEN}‚úÖ Using existing Rails master key${NC}"
    else
        RAILS_MASTER_KEY=$(openssl rand -hex 16)
        echo -e "${GREEN}‚úÖ Generated new Rails master key${NC}"
    fi
}

# Function to generate JWT secret
generate_jwt_secret() {
    echo -e "${BLUE}üîë Generating JWT secret key...${NC}"
    JWT_SECRET_KEY=$(openssl rand -hex 32)
    echo -e "${GREEN}‚úÖ JWT secret key generated${NC}"
}

# Function to create configuration files
create_config_files() {
    echo ""
    echo -e "${BLUE}üîß Creating configuration files...${NC}"


    # Create apps/api/config/deploy.yml
    mkdir -p apps/api/config
    
    # Backup existing deploy.yml if it exists
    if [ -f "apps/api/config/deploy.yml" ]; then
        echo -e "${YELLOW}üì¶ Backing up existing deploy.yml to deploy.yml.bak${NC}"
        mv apps/api/config/deploy.yml apps/api/config/deploy.yml.bak
    fi
    
    cat > apps/api/config/deploy.yml << EOF
# Kamal 2.7.0 Configuration for Asset Management System
# Generated on $(date)

service: api
image: $REGISTRY_NAMESPACE/your-app-api

# Deploy to these servers.
servers:
  web:
    hosts:
      - $SERVER_HOST
    cmd: bash -lc "until pg_isready -h api-postgres -p 5432 -U postgres; do echo 'Waiting for database...'; sleep 2; done && bin/rails db:prepare && bin/rails server -b 0.0.0.0 -p 3000"

# API is accessible through the proxy at /api path on the same domain
# Frontend accesses API via relative /api URLs
proxy:
  host: $FRONTEND_DOMAIN
  path_prefix: /api
  ssl: false
  app_port: 3000

# Credentials for your image host.
registry:
  server: $REGISTRY_SERVER
  username: $REGISTRY_USERNAME
  password:
    - KAMAL_REGISTRY_TOKEN

# Builder configuration for target platform
builder:
  arch: $BUILD_ARCH

# Inject ENV variables into containers (secrets come from .kamal/secrets).
env:
  secret:
    - RAILS_MASTER_KEY
    - JWT_SECRET_KEY
    - POSTGRES_PASSWORD
EOF

# Local storage - no additional secrets needed

cat >> apps/api/config/deploy.yml << EOF
  clear:
    RAILS_ENV: $RAILS_ENV
    RACK_ENV: $RAILS_ENV
    RAILS_LOG_TO_STDOUT: "1"
    RAILS_SERVE_STATIC_FILES: "true"
    ACTIVE_STORAGE_SERVICE: $STORAGE_TYPE
    DATABASE_URL: postgresql://postgres:$POSTGRES_PASSWORD@api-postgres:5432/$DATABASE_NAME
    REDIS_URL: redis://api-redis:6379/0

# Internal-only data stores
accessories:
  postgres:
    image: postgres:16
    host: $SERVER_HOST
    env:
      clear:
        POSTGRES_DB: $DATABASE_NAME
        POSTGRES_USER: postgres
      secret:
        - POSTGRES_PASSWORD
    directories:
      - postgres_data:/var/lib/postgresql/data

  redis:
    image: redis:7
    host: $SERVER_HOST
    cmd: redis-server --appendonly yes
    directories:
      - redis_data:/data
EOF

    # Local storage - no additional accessories needed

    # Close the accessories section
    cat >> apps/api/config/deploy.yml << EOF

# Named directories are unique per accessory to avoid accidental sharing
EOF


    # Create apps/api/.kamal/secrets
    mkdir -p apps/api/.kamal
    
    # Backup existing secrets if it exists
    if [ -f "apps/api/.kamal/secrets" ]; then
        echo -e "${YELLOW}üîí Backing up existing secrets to secrets.bak${NC}"
        mv apps/api/.kamal/secrets apps/api/.kamal/secrets.bak
    fi
    
    cat > apps/api/.kamal/secrets << EOF
# Kamal secrets file
# Generated on $(date)

RAILS_MASTER_KEY=$RAILS_MASTER_KEY
JWT_SECRET_KEY=$JWT_SECRET_KEY
POSTGRES_PASSWORD=$POSTGRES_PASSWORD
KAMAL_REGISTRY_TOKEN=$KAMAL_REGISTRY_TOKEN
EOF

    # Add storage-specific secrets
    case $STORAGE_TYPE in
        local)
            # Local storage - no additional secrets needed
            ;;
        minio)
            cat >> apps/api/.kamal/secrets << EOF
MINIO_ROOT_PASSWORD=$MINIO_SECRET_KEY
EOF
            ;;
        aws)
            cat >> apps/api/.kamal/secrets << EOF
AWS_ACCESS_KEY_ID=$AWS_ACCESS_KEY_ID
AWS_SECRET_ACCESS_KEY=$AWS_SECRET_ACCESS_KEY
EOF
            ;;
        digitalocean)
            cat >> apps/api/.kamal/secrets << EOF
DO_SPACES_ACCESS_KEY=$DO_SPACES_ACCESS_KEY
DO_SPACES_SECRET_KEY=$DO_SPACES_SECRET_KEY
EOF
            ;;
    esac

    # Add database and Redis URLs
    cat >> apps/api/.kamal/secrets << EOF

# Database and Redis URLs
DATABASE_URL=postgresql://postgres:\$POSTGRES_PASSWORD@api-postgres:5432/$DATABASE_NAME
REDIS_URL=redis://api-redis:6379/0
EOF

    # Local storage configuration
    cat >> apps/api/.kamal/secrets << EOF

# Local storage configuration
ACTIVE_STORAGE_SERVICE=local
EOF

    # Create apps/web/config/deploy.yml
    mkdir -p apps/web/config
    
    # Backup existing deploy.yml if it exists
    if [ -f "apps/web/config/deploy.yml" ]; then
        echo -e "${YELLOW}üì¶ Backing up existing web deploy.yml to deploy.yml.bak${NC}"
        mv apps/web/config/deploy.yml apps/web/config/deploy.yml.bak
    fi
    
    cat > apps/web/config/deploy.yml << EOF
# Kamal 2.7.0 Configuration for Asset Management System Web Frontend
# Generated on $(date)

service: frontend
image: $REGISTRY_NAMESPACE/your-app-web

# Deploy to these servers.
servers:
  web:
    hosts:
      - $SERVER_HOST
    cmd: node server.js

# SSL is handled by the proxy server
proxy:
  host: $FRONTEND_DOMAIN
  ssl: false
  healthcheck:
    path: /
    interval: 10
    timeout: 10

# Credentials for your image host.
registry:
  server: $REGISTRY_SERVER
  username: $REGISTRY_USERNAME
  password:
    - KAMAL_REGISTRY_PASSWORD

# Build configuration
builder:
  arch: $BUILD_ARCH
  context: .
  dockerfile: Dockerfile
  args:
    NEXT_PUBLIC_API_URL: /api

# Environment variables
env:
  clear:
    NODE_ENV: production
    PORT: 80
    HOSTNAME: 0.0.0.0
    # API URL points to the Rails API service via relative /api path
    NEXT_PUBLIC_API_URL: /api

# Logging
logging:
  driver: json-file
  options:
    max-size: "10m"
    max-file: "3"
EOF

    # Create apps/web/.kamal/secrets
    mkdir -p apps/web/.kamal
    
    # Backup existing secrets if it exists
    if [ -f "apps/web/.kamal/secrets" ]; then
        echo -e "${YELLOW}üîí Backing up existing web secrets to secrets.bak${NC}"
        mv apps/web/.kamal/secrets apps/web/.kamal/secrets.bak
    fi
    
    cat > apps/web/.kamal/secrets << EOF
# Kamal secrets file for web frontend
# Generated on $(date)

KAMAL_REGISTRY_PASSWORD=$KAMAL_REGISTRY_TOKEN
EOF

    echo -e "${GREEN}‚úÖ Configuration files created:${NC}"
    echo "  - apps/api/config/deploy.yml (Kamal configuration)"
    echo "  - apps/api/.kamal/secrets (encrypted secrets)"
    echo "  - apps/web/config/deploy.yml (Frontend Kamal configuration)"
    echo "  - apps/web/.kamal/secrets (Frontend encrypted secrets)"
}

# Function to create test configuration in sample code folder
create_test_config() {
    echo -e "${BLUE}üìù Creating test configuration in sample code folder...${NC}"
    
    # Create the sample code directory if it doesn't exist
    mkdir -p "DEVELOPER_DOCUMENTATION/sample code"
    
    # Copy the generated deploy.yml files to the sample code folder
    cp apps/api/config/deploy.yml "DEVELOPER_DOCUMENTATION/sample code/api-deploy.yml.test"
    cp apps/web/config/deploy.yml "DEVELOPER_DOCUMENTATION/sample code/web-deploy.yml.test"
    
    echo -e "${GREEN}‚úÖ Test configuration created:${NC}"
    echo "  - DEVELOPER_DOCUMENTATION/sample code/api-deploy.yml.test"
    echo "  - DEVELOPER_DOCUMENTATION/sample code/web-deploy.yml.test"
}

# Function to check if Kamal is installed
check_kamal() {
    if ! command -v kamal &> /dev/null; then
        echo -e "${RED}‚ùå Kamal is not installed. Please install it first:${NC}"
        echo "   gem install kamal"
        return 1
    fi
    return 0
}

# Function to run deployment
run_deployment() {
    echo ""
    echo -e "${BLUE}üöÄ Starting deployment process...${NC}"
    
    if ! check_kamal; then
        return 1
    fi
    
    # Deploy API first (creates database and Redis accessories)
    echo ""
    echo -e "${BLUE}üì¶ Step 1: Deploying Rails API...${NC}"
    deploy_api "$1"
    if [ $? -ne 0 ]; then
        echo -e "${RED}‚ùå API deployment failed. Aborting.${NC}"
        return 1
    fi
    
    # Deploy web frontend
    echo ""
    echo -e "${BLUE}üåê Step 2: Deploying Web Frontend...${NC}"
    deploy_web "$1"
    if [ $? -ne 0 ]; then
        echo -e "${RED}‚ùå Web frontend deployment failed. Aborting.${NC}"
        return 1
    fi
    
    echo ""
    echo -e "${GREEN}üéâ Complete deployment successful!${NC}"
    echo ""
    echo -e "${BLUE}üìã Your application is now running:${NC}"
    echo "  üåê Web Interface: http://$FRONTEND_DOMAIN"
    echo "  üîß API: http://$FRONTEND_DOMAIN/api"
    echo "  üóÑÔ∏è  Database: PostgreSQL with Redis"
    echo ""
    echo -e "${YELLOW}üí° Default admin credentials:${NC}"
    echo "  Email: admin@yourdomain.com"
    echo "  Password: your-secure-password"
    echo ""
    echo -e "${GREEN}‚úÖ You can now access your application!${NC}"
}

deploy_api() {
    echo ""
    echo -e "${BLUE}üîß Deploying Rails API...${NC}"
    
    # Change to the API directory for deployment
    cd apps/api
    
    # Check if running in developer mode
    if [ "$1" = "--dev" ]; then
        echo ""
        echo -e "${BLUE}üîß Developer Mode: Building and pushing API image...${NC}"
        echo -e "${YELLOW}‚ö†Ô∏è  This will build and push new images to the registry.${NC}"
        
        echo ""
        echo -e "${BLUE}üîß Running kamal setup (build and push)...${NC}"
        if ! kamal setup -c config/deploy.yml; then
            echo -e "${RED}‚ùå API setup failed. Please check your server configuration.${NC}"
            echo -e "${YELLOW}üí° Manual commands:${NC}"
            echo "   cd apps/api"
            echo "   kamal setup -c config/deploy.yml"
            echo "   kamal deploy -c config/deploy.yml"
            return 1
        fi
    else
        echo ""
        echo -e "${BLUE}üì• Customer Mode: Pulling existing API image...${NC}"
        echo -e "${GREEN}‚úÖ Skipping build step - using pre-built images${NC}"
        
        # Validate that the image exists
        echo ""
        echo -e "${BLUE}üîç Validating API image exists in registry...${NC}"
        if ! docker manifest inspect "$REGISTRY_SERVER/$REGISTRY_NAMESPACE/your-app-api:latest" &> /dev/null; then
            echo -e "${RED}‚ùå API image not found in registry: $REGISTRY_SERVER/$REGISTRY_NAMESPACE/your-app-api:latest${NC}"
            echo -e "${YELLOW}üí° This could mean:${NC}"
            echo "  - The image hasn't been built and pushed yet"
            echo "  - The registry URL is incorrect"
            echo "  - You need to contact the developer for a fresh image"
            return 1
        else
            echo -e "${GREEN}‚úÖ API image found in registry${NC}"
        fi
        
        echo ""
        echo -e "${BLUE}üîß Running kamal setup (pull only)...${NC}"
        if ! kamal setup -c config/deploy.yml --skip-push; then
            echo -e "${RED}‚ùå API setup failed. Please check your server configuration.${NC}"
            echo -e "${YELLOW}üí° Manual commands:${NC}"
            echo "   cd apps/api"
            echo "   kamal setup -c config/deploy.yml --skip-push"
            echo "   kamal deploy -c config/deploy.yml"
            return 1
        fi
    fi
    
    echo ""
    echo -e "${GREEN}‚úÖ API deployment completed successfully!${NC}"
    echo ""
    echo -e "${BLUE}üîß Running kamal deploy for API...${NC}"
    if ! kamal deploy -c config/deploy.yml; then
        echo -e "${RED}‚ùå API deploy failed. Please check your server configuration.${NC}"
        echo -e "${YELLOW}üí° Manual commands:${NC}"
        echo "   cd apps/api"
        echo "   kamal deploy -c config/deploy.yml"
        return 1
    fi
    
    echo ""
    echo -e "${GREEN}‚úÖ API is now running with database and Redis accessories!${NC}"
    
    # Ensure deploy lock is released after API deployment
    echo "üîì Releasing deploy lock after API deployment..."
    kamal lock release 2>/dev/null || true
    
    # Return to project root
    cd ../..
}

deploy_web() {
    echo ""
    echo -e "${BLUE}üîß Deploying Web Frontend...${NC}"
    
    # Change to the web directory for deployment
    cd apps/web
    
    # Check if running in developer mode
    if [ "$1" = "--dev" ]; then
        echo ""
        echo -e "${BLUE}üîß Developer Mode: Building and pushing web image...${NC}"
        echo -e "${YELLOW}‚ö†Ô∏è  This will build and push new images to the registry.${NC}"
        
        echo ""
        echo -e "${BLUE}üîß Running kamal setup (build and push)...${NC}"
        if ! kamal setup -c config/deploy.yml; then
            echo -e "${RED}‚ùå Web setup failed. Please check your server configuration.${NC}"
            echo -e "${YELLOW}üí° Manual commands:${NC}"
            echo "   cd apps/web"
            echo "   kamal setup -c config/deploy.yml"
            echo "   kamal deploy -c config/deploy.yml"
            return 1
        fi
    else
        echo ""
        echo -e "${BLUE}üì• Customer Mode: Pulling existing web image...${NC}"
        echo -e "${GREEN}‚úÖ Skipping build step - using pre-built images${NC}"
        
        # Validate that the image exists
        echo ""
        echo -e "${BLUE}üîç Validating web image exists in registry...${NC}"
        if ! docker manifest inspect "$REGISTRY_SERVER/$REGISTRY_NAMESPACE/your-app-web:latest" &> /dev/null; then
            echo -e "${RED}‚ùå Web image not found in registry: $REGISTRY_SERVER/$REGISTRY_NAMESPACE/your-app-web:latest${NC}"
            echo -e "${YELLOW}üí° This could mean:${NC}"
            echo "  - The image hasn't been built and pushed yet"
            echo "  - The registry URL is incorrect"
            echo "  - You need to contact the developer for a fresh image"
            return 1
        else
            echo -e "${GREEN}‚úÖ Web image found in registry${NC}"
        fi
        
        echo ""
        echo -e "${BLUE}üîß Running kamal setup (pull only)...${NC}"
        if ! kamal setup -c config/deploy.yml --skip-push; then
            echo -e "${RED}‚ùå Web setup failed. Please check your server configuration.${NC}"
            echo -e "${YELLOW}üí° Manual commands:${NC}"
            echo "   cd apps/web"
            echo "   kamal setup -c config/deploy.yml --skip-push"
            echo "   kamal deploy -c config/deploy.yml"
            return 1
        fi
    fi
    
    echo ""
    echo -e "${GREEN}‚úÖ Web frontend deployment completed successfully!${NC}"
    echo ""
    echo -e "${BLUE}üîß Running kamal deploy for web frontend...${NC}"
    if ! kamal deploy -c config/deploy.yml; then
        echo -e "${RED}‚ùå Web deploy failed. Please check your server configuration.${NC}"
        echo -e "${YELLOW}üí° Manual commands:${NC}"
        echo "   cd apps/web"
        echo "   kamal deploy -c config/deploy.yml"
        return 1
    fi
    
    echo ""
    echo -e "${GREEN}‚úÖ Web frontend is now running and accessible!${NC}"
    
    # Ensure deploy lock is released after web deployment
    echo "üîì Releasing deploy lock after web deployment..."
    kamal lock release 2>/dev/null || true
    
    # Return to project root
    cd ../..
}

# Function to check for existing containers and ask for cleanup
check_existing_containers() {
    echo ""
    echo -e "${BLUE}üîç Checking for existing containers...${NC}"
    
    # Check for existing Docker state that could cause conflicts
    local api_containers=$(ssh -p "$SSH_PORT" "$SSH_USER@$SERVER_HOST" "docker ps -a --filter label=service=api --format '{{.Names}}' 2>/dev/null || echo ''" 2>/dev/null || echo "")
    local web_containers=$(ssh -p "$SSH_PORT" "$SSH_USER@$SERVER_HOST" "docker ps -a --filter label=service=web --format '{{.Names}}' 2>/dev/null || echo ''" 2>/dev/null || echo "")
    local frontend_containers=$(ssh -p "$SSH_PORT" "$SSH_USER@$SERVER_HOST" "docker ps -a --filter label=service=frontend --format '{{.Names}}' 2>/dev/null || echo ''" 2>/dev/null || echo "")
    local postgres_containers=$(ssh -p "$SSH_PORT" "$SSH_USER@$SERVER_HOST" "docker ps -a --filter label=service=api-postgres --format '{{.Names}}' 2>/dev/null || echo ''" 2>/dev/null || echo "")
    local redis_containers=$(ssh -p "$SSH_PORT" "$SSH_USER@$SERVER_HOST" "docker ps -a --filter label=service=api-redis --format '{{.Names}}' 2>/dev/null || echo ''" 2>/dev/null || echo "")
    
    # Check for volumes, networks, and images
    local existing_volumes=$(ssh -p "$SSH_PORT" "$SSH_USER@$SERVER_HOST" "docker volume ls --filter name=api --filter name=frontend --filter name=kamal --format '{{.Name}}' 2>/dev/null || echo ''" 2>/dev/null || echo "")
    local existing_networks=$(ssh -p "$SSH_PORT" "$SSH_USER@$SERVER_HOST" "docker network ls --filter name=kamal --format '{{.Name}}' 2>/dev/null || echo ''" 2>/dev/null || echo "")
    local existing_images=$(ssh -p "$SSH_PORT" "$SSH_USER@$SERVER_HOST" "docker images --filter reference='*your-app*' --format '{{.Repository}}:{{.Tag}}' 2>/dev/null || echo ''" 2>/dev/null || echo "")
    local existing_directories=$(ssh -p "$SSH_PORT" "$SSH_USER@$SERVER_HOST" "ls -d /root/*postgres* /root/*redis* 2>/dev/null | head -5" 2>/dev/null || echo "")
    
    local has_existing=false
    
    if [ -n "$api_containers" ] || [ -n "$web_containers" ] || [ -n "$frontend_containers" ] || [ -n "$postgres_containers" ] || [ -n "$redis_containers" ] || [ -n "$existing_volumes" ] || [ -n "$existing_networks" ] || [ -n "$existing_images" ] || [ -n "$existing_directories" ]; then
        has_existing=true
        echo -e "${YELLOW}‚ö†Ô∏è  Found existing Docker state that could cause conflicts:${NC}"
        
        if [ -n "$api_containers" ]; then
            echo "  üì¶ API containers: $api_containers"
        fi
        if [ -n "$web_containers" ]; then
            echo "  üåê Web containers: $web_containers"
        fi
        if [ -n "$frontend_containers" ]; then
            echo "  üåê Frontend containers: $frontend_containers"
        fi
        if [ -n "$postgres_containers" ]; then
            echo "  üóÑÔ∏è  PostgreSQL containers: $postgres_containers"
        fi
        if [ -n "$redis_containers" ]; then
            echo "  üî¥ Redis containers: $redis_containers"
        fi
        if [ -n "$existing_volumes" ]; then
            echo "  üíæ Existing volumes: $existing_volumes"
        fi
        if [ -n "$existing_networks" ]; then
            echo "  üåê Existing networks: $existing_networks"
        fi
        if [ -n "$existing_images" ]; then
            echo "  üñºÔ∏è  Existing images: $existing_images"
        fi
        if [ -n "$existing_directories" ]; then
            echo "  üìÅ Existing data directories: $existing_directories"
        fi
        
        echo ""
        echo -e "${YELLOW}This usually indicates a previous application deployment.${NC}"
        echo -e "${YELLOW}To avoid password conflicts and ensure a clean deployment,${NC}"
        echo -e "${YELLOW}we recommend removing existing containers first.${NC}"
        echo -e "${GREEN}Note: Only containers tagged with our service labels will be affected.${NC}"
        echo ""
        
        while true; do
            echo "Choose cleanup option:"
            echo "1) Remove only your application containers (recommended)"
            echo "2) Skip cleanup (may cause deployment issues)"
            echo "3) Remove all Docker objects (containers, images, volumes, networks) but keep Docker installed"
            echo -e "${RED}4) Complete server wipe - Remove Docker entirely and reinstall (nuclear option)${NC}"
            read -p "Enter choice [1-4]: " cleanup_choice
            case $cleanup_choice in
                1)
                    echo ""
                    echo -e "${BLUE}üßπ Cleaning up existing Asset Management System containers...${NC}"
                    
                    # Remove existing containers (only those with our specific service labels)
                    if [ -n "$api_containers" ]; then
                        echo "  Removing your application API containers..."
                        ssh -p "$SSH_PORT" "$SSH_USER@$SERVER_HOST" "docker stop $api_containers 2>/dev/null || true; docker rm $api_containers 2>/dev/null || true"
                    fi
                    if [ -n "$web_containers" ]; then
                        echo "  Removing your application Web containers..."
                        ssh -p "$SSH_PORT" "$SSH_USER@$SERVER_HOST" "docker stop $web_containers 2>/dev/null || true; docker rm $web_containers 2>/dev/null || true"
                    fi
                    if [ -n "$frontend_containers" ]; then
                        echo "  Removing your application Frontend containers..."
                        ssh -p "$SSH_PORT" "$SSH_USER@$SERVER_HOST" "docker stop $frontend_containers 2>/dev/null || true; docker rm $frontend_containers 2>/dev/null || true"
                    fi
                    if [ -n "$postgres_containers" ]; then
                        echo "  Removing your application PostgreSQL containers..."
                        ssh -p "$SSH_PORT" "$SSH_USER@$SERVER_HOST" "docker stop $postgres_containers 2>/dev/null || true; docker rm $postgres_containers 2>/dev/null || true"
                    fi
                    if [ -n "$redis_containers" ]; then
                        echo "  Removing your application Redis containers..."
                        ssh -p "$SSH_PORT" "$SSH_USER@$SERVER_HOST" "docker stop $redis_containers 2>/dev/null || true; docker rm $redis_containers 2>/dev/null || true"
                    fi
                    
                    # Remove existing volumes and networks
                    if [ -n "$existing_volumes" ]; then
                        echo "  Removing your application volumes..."
                        ssh -p "$SSH_PORT" "$SSH_USER@$SERVER_HOST" "docker volume rm $existing_volumes 2>/dev/null || true"
                    fi
                    if [ -n "$existing_networks" ]; then
                        echo "  Removing your application networks..."
                        ssh -p "$SSH_PORT" "$SSH_USER@$SERVER_HOST" "docker network rm $existing_networks 2>/dev/null || true"
                    fi
                    
                    # Remove existing data directories to ensure fresh database initialization
                    echo "  Removing your application data directories..."
                    ssh -p "$SSH_PORT" "$SSH_USER@$SERVER_HOST" "rm -rf /root/api-postgres /root/api-redis /root/frontend-postgres /root/frontend-redis 2>/dev/null || true"
                    ssh -p "$SSH_PORT" "$SSH_USER@$SERVER_HOST" "find /root -name '*postgres*' -type d -exec rm -rf {} + 2>/dev/null || true"
                    ssh -p "$SSH_PORT" "$SSH_USER@$SERVER_HOST" "find /root -name '*redis*' -type d -exec rm -rf {} + 2>/dev/null || true"
                    
                    echo -e "${GREEN}‚úÖ Cleanup completed successfully!${NC}"
                    break
                    ;;
                2)
                    echo ""
                    echo -e "${YELLOW}‚ö†Ô∏è  Proceeding with existing containers.${NC}"
                    echo -e "${YELLOW}Note: This may cause deployment issues if passwords don't match.${NC}"
                    break
                    ;;
                3)
                    echo ""
                    echo -e "${BLUE}üßπ Removing all Docker objects but keeping Docker installed...${NC}"
                    
                    # Stop all containers
                    echo "  Stopping all Docker containers..."
                    ssh -p "$SSH_PORT" "$SSH_USER@$SERVER_HOST" "docker stop \$(docker ps -aq) 2>/dev/null || true"
                    
                    # Remove all containers
                    echo "  Removing all Docker containers..."
                    ssh -p "$SSH_PORT" "$SSH_USER@$SERVER_HOST" "docker rm \$(docker ps -aq) 2>/dev/null || true"
                    
                    # Remove all images
                    echo "  Removing all Docker images..."
                    ssh -p "$SSH_PORT" "$SSH_USER@$SERVER_HOST" "docker rmi \$(docker images -aq) 2>/dev/null || true"
                    
                    # Remove all volumes
                    echo "  Removing all Docker volumes..."
                    ssh -p "$SSH_PORT" "$SSH_USER@$SERVER_HOST" "docker volume rm \$(docker volume ls -q) 2>/dev/null || true"
                    
                    # Remove all networks
                    echo "  Removing all Docker networks..."
                    ssh -p "$SSH_PORT" "$SSH_USER@$SERVER_HOST" "docker network rm \$(docker network ls -q) 2>/dev/null || true"
                    
                    # Remove Docker system
                    echo "  Cleaning up Docker system..."
                    ssh -p "$SSH_PORT" "$SSH_USER@$SERVER_HOST" "docker system prune -af --volumes 2>/dev/null || true"
                    
                    # Remove all persistent data directories
                    echo "  Removing all persistent data directories..."
                    ssh -p "$SSH_PORT" "$SSH_USER@$SERVER_HOST" "rm -rf /root/api-postgres /root/api-redis /root/frontend-postgres /root/frontend-redis /root/*-postgres /root/*-redis 2>/dev/null || true"
                    ssh -p "$SSH_PORT" "$SSH_USER@$SERVER_HOST" "rm -rf /var/lib/docker/volumes/* 2>/dev/null || true"
                    ssh -p "$SSH_PORT" "$SSH_USER@$SERVER_HOST" "find /root -name '*postgres*' -type d -exec rm -rf {} + 2>/dev/null || true"
                    ssh -p "$SSH_PORT" "$SSH_USER@$SERVER_HOST" "find /root -name '*redis*' -type d -exec rm -rf {} + 2>/dev/null || true"
                    
                    echo -e "${GREEN}‚úÖ All Docker objects removed successfully!${NC}"
                    echo -e "${GREEN}Docker remains installed and ready for deployment.${NC}"
                    break
                    ;;
                4)
                    echo ""
                    echo -e "${RED}‚ö†Ô∏è  NUCLEAR OPTION: Complete server wipe selected!${NC}"
                    echo -e "${RED}This will remove Docker entirely and reinstall it.${NC}"
                    echo -e "${RED}ALL Docker containers, images, volumes, networks, and persistent storage will be lost!${NC}"
                    echo ""
                    read -p "Are you absolutely sure you want to proceed? Type 'YES' to confirm: " confirm_wipe
                    if [ "$confirm_wipe" = "YES" ]; then
                        echo ""
                        echo -e "${BLUE}üßπ Performing complete server wipe...${NC}"
                        
                        # Stop all containers
                        echo "  Stopping all Docker containers..."
                        ssh -p "$SSH_PORT" "$SSH_USER@$SERVER_HOST" "docker stop \$(docker ps -aq) 2>/dev/null || true"
                        
                        # Remove all containers
                        echo "  Removing all Docker containers..."
                        ssh -p "$SSH_PORT" "$SSH_USER@$SERVER_HOST" "docker rm \$(docker ps -aq) 2>/dev/null || true"
                        
                        # Remove all images
                        echo "  Removing all Docker images..."
                        ssh -p "$SSH_PORT" "$SSH_USER@$SERVER_HOST" "docker rmi \$(docker images -aq) 2>/dev/null || true"
                        
                        # Remove all volumes
                        echo "  Removing all Docker volumes..."
                        ssh -p "$SSH_PORT" "$SSH_USER@$SERVER_HOST" "docker volume rm \$(docker volume ls -q) 2>/dev/null || true"
                        
                        # Remove all networks
                        echo "  Removing all Docker networks..."
                        ssh -p "$SSH_PORT" "$SSH_USER@$SERVER_HOST" "docker network rm \$(docker network ls -q) 2>/dev/null || true"
                        
                        # Remove Docker system
                        echo "  Removing Docker system..."
                        ssh -p "$SSH_PORT" "$SSH_USER@$SERVER_HOST" "docker system prune -af --volumes 2>/dev/null || true"
                        
                        # Remove all persistent data directories
                        echo "  Removing all persistent data directories..."
                        ssh -p "$SSH_PORT" "$SSH_USER@$SERVER_HOST" "rm -rf /root/api-postgres /root/api-redis /root/frontend-postgres /root/frontend-redis /root/*-postgres /root/*-redis 2>/dev/null || true"
                        ssh -p "$SSH_PORT" "$SSH_USER@$SERVER_HOST" "rm -rf /var/lib/docker/volumes/* 2>/dev/null || true"
                        ssh -p "$SSH_PORT" "$SSH_USER@$SERVER_HOST" "find /root -name '*postgres*' -type d -exec rm -rf {} + 2>/dev/null || true"
                        ssh -p "$SSH_PORT" "$SSH_USER@$SERVER_HOST" "find /root -name '*redis*' -type d -exec rm -rf {} + 2>/dev/null || true"
                        
                        # Uninstall Docker
                        echo "  Uninstalling Docker..."
                        ssh -p "$SSH_PORT" "$SSH_USER@$SERVER_HOST" "apt-get remove -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin 2>/dev/null || true"
                        ssh -p "$SSH_PORT" "$SSH_USER@$SERVER_HOST" "apt-get purge -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin 2>/dev/null || true"
                        ssh -p "$SSH_PORT" "$SSH_USER@$SERVER_HOST" "rm -rf /var/lib/docker /var/lib/containerd /etc/docker 2>/dev/null || true"
                        
                        # Reinstall Docker using kamal setup
                        echo "  Reinstalling Docker using kamal setup..."
                        echo "  Note: Docker will be installed automatically when kamal setup runs"
                        
                        echo -e "${GREEN}‚úÖ Complete server wipe and Docker reinstall completed!${NC}"
                        break
                    else
                        echo -e "${YELLOW}Server wipe cancelled.${NC}"
                        continue
                    fi
                    ;;
                * )
                    echo -e "${YELLOW}Please enter 1, 2, or 3.${NC}"
                    ;;
            esac
        done
    else
        echo -e "${GREEN}‚úÖ No existing application containers found. Ready for fresh deployment.${NC}"
    fi
}

# Function to show manual commands
show_manual_commands() {
    echo ""
    echo -e "${BLUE}üìã Manual Deployment Commands:${NC}"
    echo "============================="
    echo ""
    echo "To deploy manually, run these commands:"
    echo ""
    echo -e "${YELLOW}Step 1: Deploy Rails API${NC}"
    echo "1. cd apps/api"
    echo "2. kamal setup -c config/deploy.yml"
    echo "3. kamal deploy -c config/deploy.yml"
    echo ""
    echo -e "${YELLOW}Step 2: Deploy Web Frontend${NC}"
    echo "4. cd ../web"
    echo "5. kamal setup -c config/deploy.yml"
    echo "6. kamal deploy -c config/deploy.yml"
    echo ""
    echo -e "${YELLOW}Useful commands:${NC}"
    echo "  kamal app logs -c config/deploy.yml     - View application logs"
    echo "  kamal app restart -c config/deploy.yml  - Restart the application"
    echo "  kamal remove -c config/deploy.yml       - Remove the deployment"
    echo ""
    echo -e "${GREEN}After deployment, access your system at: http://$FRONTEND_DOMAIN${NC}"
    echo -e "${GREEN}API will be available at: http://$FRONTEND_DOMAIN/api${NC}"
    echo ""
}

# Main script logic
main() {
    # Check for help flag
    if [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
        echo "Usage: $0 [--dev]"
        echo ""
        echo "Options:"
        echo "  --dev    Developer mode: Build and push images to registry"
        echo "           Uses KAMAL_REGISTRY_TOKEN environment variable if available"
        echo "           Default: Customer mode: Pull existing images only"
        echo ""
        echo "Examples:"
        echo "  $0           # Customer deployment (pull existing images)"
        echo "  $0 --dev     # Developer deployment (build and push images)"
        exit 0
    fi
    
    # Check if we're in the right directory
    if [ ! -f "apps/api/Gemfile" ]; then
        echo -e "${RED}Error: This script must be run from the project root directory.${NC}"
        echo "Please cd to the directory containing apps/api/Gemfile"
        exit 1
    fi

    # Collect configuration
    collect_config "$1"
    
    # Show summary and get confirmation
    while true; do
        show_summary
        read -p "Is this correct? (y/n/e for edit): " confirm
        
        case $confirm in
            [Yy]* )
                break
                ;;
            [Nn]* )
                echo -e "${YELLOW}Setup cancelled.${NC}"
                exit 0
                ;;
            [Ee]* )
                echo -e "${BLUE}Re-running configuration with current values as defaults...${NC}"
                collect_config
                ;;
            * )
                echo -e "${YELLOW}Please answer y (yes), n (no), or e (edit).${NC}"
                ;;
        esac
    done
    
    # Check for existing containers and offer cleanup
    check_existing_containers
    
    # Generate secrets
    get_rails_master_key
    generate_jwt_secret
    
    # Create configuration files
    create_config_files
    
    # Create test configuration
    create_test_config
    
    echo ""
    echo -e "${YELLOW}üîí Security Notes:${NC}"
    echo "  - .kamal/secrets contains sensitive data - never commit to git"
    echo "  - All secrets are stored securely in the .kamal/secrets file"
    echo "  - No environment variables need to be set manually"
    echo ""
    
    # Ask if user wants to deploy now
    echo -e "${BLUE}üöÄ Ready to deploy now? (y/n):${NC}"
    read -p "" deploy_now
    
    case $deploy_now in
        [Yy]* )
            echo ""
            echo -e "${YELLOW}‚ö†Ô∏è  Important: This will attempt to deploy using your registry token.${NC}"
            echo "If you encounter authentication errors, it means:"
            echo "  - Your registry token is invalid or expired"
            echo "  - You need a fresh token from the developer"
            echo "  - The token doesn't have the correct permissions"
            echo ""
            read -p "Continue with deployment? (y/n): " confirm_deploy
            case $confirm_deploy in
                [Yy]* )
                    run_deployment "$1"
                    ;;
                [Nn]* )
                    show_manual_commands
                    ;;
                * )
                    echo -e "${YELLOW}Assuming no. Showing manual commands...${NC}"
                    show_manual_commands
                    ;;
            esac
            ;;
        [Nn]* )
            show_manual_commands
            ;;
        * )
            echo -e "${YELLOW}Assuming no. Showing manual commands...${NC}"
            show_manual_commands
            ;;
    esac
    
    echo ""
    echo -e "${GREEN}üéâ Setup complete!${NC}"
}

# Run main function
main "$@"